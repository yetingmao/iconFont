(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.opentype = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Run-time checking of preconditions.

'use strict';

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function(predicate, message) {
    if (!predicate) {
        throw new Error(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;

},{}],3:[function(require,module,exports){
// Drawing utility functions.

'use strict';

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;

},{}],4:[function(require,module,exports){
// Glyph encoding

'use strict';

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

// This is the encoding used for fonts created from scratch.
// It loops through all glyphs and finds the appropriate unicode value.
// Since it's linear time, other encodings will be faster.
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs[i];
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

function CmapEncoding(cmap) {
    this.cmap = cmap;
}

CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

function GlyphNames(post) {
    var i;
    switch (post.version) {
    case 1:
        this.names = exports.standardNames.slice();
        break;
    case 2:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] < exports.standardNames.length) {
                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
            } else {
                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
            }
        }

        break;
    case 2.5:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
        }

        break;
    case 3:
        this.names = [];
        break;
    }
}

GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};

GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};

function addGlyphNames(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);
    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs[glyphIndex];
        glyph.addUnicode(parseInt(c));
    }

    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs[i];
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

},{}],5:[function(require,module,exports){
// The Font object

'use strict';

var path = require('./path');
var sfnt = require('./tables/sfnt');
var encoding = require('./encoding');

// A Font represents a loaded OpenType font file.
// It contains a set of glyphs and methods to draw text on a drawing context,
// or to get a path representing the text.
function Font(options) {
    options = options || {};

    // OS X will complain if the names are empty, so we put a single space everywhere by default.
    this.familyName = options.familyName || ' ';
    this.styleName = options.styleName || ' ';
    this.designer = options.designer || ' ';
    this.designerURL = options.designerURL || ' ';
    this.manufacturer = options.manufacturer || ' ';
    this.manufacturerURL = options.manufacturerURL || ' ';
    this.license = options.license || ' ';
    this.licenseURL = options.licenseURL || ' ';
    this.version = options.version || 'Version 0.1';
    this.description = options.description || ' ';
    this.copyright = options.copyright || ' ';
    this.trademark = options.trademark || ' ';
    this.unitsPerEm = options.unitsPerEm || 1000;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.supported = true;
    this.glyphs = options.glyphs || [];
    this.encoding = new encoding.DefaultEncoding(this);
    this.tables = {};
}

// Check if the font has a glyph for the given character.
Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

// Convert the given character to a single glyph index.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};

// Convert the given character to a single Glyph object.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        // .notdef
        glyph = this.glyphs[0];
    }

    return glyph;
};

// Convert the given text to a list of Glyph objects.
// Note that there is no strict one-to-one mapping between characters and
// glyphs, so the list of returned glyphs can be larger or smaller than the
// length of the given string.
Font.prototype.stringToGlyphs = function(s) {
    var glyphs = [];
    for (var i = 0; i < s.length; i += 1) {
        var c = s[i];
        glyphs.push(this.charToGlyph(c));
    }

    return glyphs;
};

Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

Font.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nametoGlyphIndex(name);
    var glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        // .notdef
        glyph = this.glyphs[0];
    }

    return glyph;
};

Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

// Retrieve the value of the kerning pair between the left glyph (or its index)
// and the right glyph (or its index). If no kerning pair is found, return 0.
// The kerning value gets added to the advance width when calculating the spacing
// between glyphs.
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

// Helper function that invokes the given callback for each glyph in the given text.
// The callback gets `(glyph, x, y, fontSize, options)`.
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    if (!this.supported) {
        return;
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || {};
    var kerning = options.kerning === undefined ? true : options.kerning;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (kerning && i < glyphs.length - 1) {
            var kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
    }
};

// Create a Path object that represents the given text.
//
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
//
// Returns a Path object.
Font.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize);
        fullPath.extend(glyphPath);
    });

    return fullPath;
};

// Draw the text on the given drawing context.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

// Draw the points of all glyphs in the text.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

// Draw lines indicating important font measurements for all glyphs in the text.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

// Validate
Font.prototype.validate = function() {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertStringAttribute(attrName) {
        assert(_this[attrName] && _this[attrName].trim().length > 0, 'No ' + attrName + ' specified.');
    }

    // Identification information
    assertStringAttribute('familyName');
    assertStringAttribute('weightName');
    assertStringAttribute('manufacturer');
    assertStringAttribute('copyright');
    assertStringAttribute('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
Font.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};

Font.prototype.toBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

// Initiate a download of the OpenType font.
Font.prototype.download = function() {
    var fileName = this.familyName.replace(/\s/g, '') + '-' + this.styleName + '.otf';
    var buffer = this.toBuffer();

    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function(fs) {
        fs.root.getFile(fileName, {create: true}, function(fileEntry) {
            fileEntry.createWriter(function(writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], {type: 'font/opentype'});
                writer.write(blob);

                writer.addEventListener('writeend', function() {
                    // Navigating to the file will download it.
                    location.href = fileEntry.toURL();
                }, false);
            });
        });
    },

    function(err) {
        throw err;
    });
};

exports.Font = Font;

},{"./encoding":4,"./path":9,"./tables/sfnt":24}],6:[function(require,module,exports){
// The Glyph object

'use strict';

var check = require('./check');
var draw = require('./draw');
var path = require('./path');

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
function Glyph(options) {
    this.font = options.font || null;
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    this.xMin = options.xMin || 0;
    this.yMin = options.yMin || 0;
    this.xMax = options.xMax || 0;
    this.yMax = options.yMax || 0;
    this.advanceWidth = options.advanceWidth || 0;
    this.path = options.path || null;
}

Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

// Convert the glyph to a Path we can draw on a drawing context.
//
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.getPath = function(x, y, fontSize) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var scale = 1 / this.font.unitsPerEm * fontSize;
    var p = new path.Path();
    var commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                               x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                      x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

// Split the glyph into contours.
// This function is here for backwards compatibility, and to
// provide raw access to the TrueType glyph outlines.
Glyph.prototype.getContours = function() {
    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: 0
    };
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

// Draw the glyph on the given context.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.draw = function(ctx, x, y, fontSize) {
    this.getPath(x, y, fontSize).draw(ctx);
};

// Draw the points of the glyph.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.font.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

// Draw lines indicating important font measurements.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (this.xMin * scale), -10000, x + (this.xMin * scale), 10000);
    draw.line(ctx, x + (this.xMax * scale), -10000, x + (this.xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-this.yMin * scale), 10000, y + (-this.yMin * scale));
    draw.line(ctx, -10000, y + (-this.yMax * scale), 10000, y + (-this.yMax * scale));

    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (this.advanceWidth * scale), -10000, x + (this.advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;

},{"./check":2,"./draw":3,"./path":9}],7:[function(require,module,exports){
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2014 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */

'use strict';

var encoding = require('./encoding');
var _font = require('./font');
var glyph = require('./glyph');
var parse = require('./parse');
var path = require('./path');

var cmap = require('./tables/cmap');
var cff = require('./tables/cff');
var glyf = require('./tables/glyf');
var gpos = require('./tables/gpos');
var head = require('./tables/head');
var hhea = require('./tables/hhea');
var hmtx = require('./tables/hmtx');
var kern = require('./tables/kern');
var loca = require('./tables/loca');
var maxp = require('./tables/maxp');
var _name = require('./tables/name');
var os2 = require('./tables/os2');
var post = require('./tables/post');

// File loaders /////////////////////////////////////////////////////////

// Convert a Node.js Buffer to an ArrayBuffer
function toArrayBuffer(buffer) {
    var arrayBuffer = new ArrayBuffer(buffer.length);
    var data = new Uint8Array(arrayBuffer);
    for (var i = 0; i < buffer.length; i += 1) {
        data[i] = buffer[i];
    }

    return arrayBuffer;
}

function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function(err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, toArrayBuffer(buffer));
    });
}

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }

        return callback(null, request.response);
    };

    request.send();
}

// Public API ///////////////////////////////////////////////////////////

// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
// If the file could not be parsed (most likely because it contains Postscript outlines)
// we return an empty Font object with the `supported` flag set to `false`.
function parseBuffer(buffer) {
    var indexToLocFormat;
    var hmtxOffset;
    var glyfOffset;
    var locaOffset;
    var cffOffset;
    var kernOffset;
    var gposOffset;

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.

    var font = new _font.Font();
    var data = new DataView(buffer, 0);

    var version = parse.getFixed(data, 0);
    if (version === 1.0) {
        font.outlinesFormat = 'truetype';
    } else {
        version = parse.getTag(data, 0);
        if (version === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType version ' + version);
        }
    }

    var numTables = parse.getUShort(data, 4);

    // Offset into the table records.
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 8);
        switch (tag) {
        case 'cmap':
            font.tables.cmap = cmap.parse(data, offset);
            font.encoding = new encoding.CmapEncoding(font.tables.cmap);
            if (!font.encoding) {
                font.supported = false;
            }

            break;
        case 'head':
            font.tables.head = head.parse(data, offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
        case 'hhea':
            font.tables.hhea = hhea.parse(data, offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
        case 'hmtx':
            hmtxOffset = offset;
            break;
        case 'maxp':
            font.tables.maxp = maxp.parse(data, offset);
            font.numGlyphs = font.tables.maxp.numGlyphs;
            break;
        case 'name':
            font.tables.name = _name.parse(data, offset);
            font.familyName = font.tables.name.fontFamily;
            font.styleName = font.tables.name.fontSubfamily;
            break;
        case 'OS/2':
            font.tables.os2 = os2.parse(data, offset);
            break;
        case 'post':
            font.tables.post = post.parse(data, offset);
            font.glyphNames = new encoding.GlyphNames(font.tables.post);
            break;
        case 'glyf':
            glyfOffset = offset;
            break;
        case 'loca':
            locaOffset = offset;
            break;
        case 'CFF ':
            cffOffset = offset;
            break;
        case 'kern':
            kernOffset = offset;
            break;
        case 'GPOS':
            gposOffset = offset;
            break;
        }
        p += 16;
    }

    if (glyfOffset && locaOffset) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = loca.parse(data, locaOffset, font.numGlyphs, shortVersion);
        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
        encoding.addGlyphNames(font);
    } else if (cffOffset) {
        cff.parse(data, cffOffset, font);
        encoding.addGlyphNames(font);
    } else {
        font.supported = false;
    }

    if (font.supported) {
        if (kernOffset) {
            font.kerningPairs = kern.parse(data, kernOffset);
        } else {
            font.kerningPairs = {};
        }

        if (gposOffset) {
            gpos.parse(data, gposOffset, font);
        }
    }

    return font;
}

// Asynchronously load the font from a URL or a filesystem. When done, call the callback
// with two arguments `(err, font)`. The `err` will be null on success,
// the `font` is a Font object.
//
// We use the node.js callback convention so that
// opentype.js can integrate with frameworks like async.js.
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function(err, arrayBuffer) {
        if (err) {
            return callback(err);
        }

        var font = parseBuffer(arrayBuffer);
        if (!font.supported) {
            return callback('Font is not supported (is this a Postscript font?)');
        }

        return callback(null, font);
    });
}

exports._parse = parse;
exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.parse = parseBuffer;
exports.load = load;

},{"./encoding":4,"./font":5,"./glyph":6,"./parse":8,"./path":9,"./tables/cff":11,"./tables/cmap":12,"./tables/glyf":13,"./tables/gpos":14,"./tables/head":15,"./tables/hhea":16,"./tables/hmtx":17,"./tables/kern":18,"./tables/loca":19,"./tables/maxp":20,"./tables/name":21,"./tables/os2":22,"./tables/post":23,"fs":1}],8:[function(require,module,exports){
// Parsing utility functions

'use strict';

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
exports.getUShort = function(dataView, offset) {
    return dataView.getUint16(offset, false);
};

exports.getCard16 = exports.getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function(dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function(dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = exports.getUShort(dataView, offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function() {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v / 65536;
};

Parser.prototype.parseVersion = function() {
    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

exports.Parser = Parser;

},{}],9:[function(require,module,exports){
// Geometric objects

'use strict';

// A bézier path containing a set of path commands similar to a SVG path.
// Paths can be drawn on a context using `draw`.
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};

// Add the given path or list of commands to the commands of this path.
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

// Draw the path to a 2D context.
Path.prototype.draw = function(ctx) {
    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

// Convert the Path to a string of path data instructions
// See http://www.w3.org/TR/SVG/paths.html#PathData
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toPathData = function(decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

// Convert the path to a SVG <path> element, as a string.
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill & this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

exports.Path = Path;

},{}],10:[function(require,module,exports){
// Table metadata

'use strict';

var check = require('./check');
var encode = require('./types').encode;
var sizeOf = require('./types').sizeOf;

function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

Table.prototype.sizeOf = function() {
    var v = 0;
    for (var i = 0; i < this.fields.length; i += 1) {
        var field = this.fields[i];
        var value = this[field.name];
        if (value === undefined) {
            value = field.value;
        }

        if (typeof value.sizeOf === 'function') {
            v += value.sizeOf();
        } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);
            v += sizeOfFunction(value);
        }
    }

    return v;
};

Table.prototype.encode = function() {
    return encode.TABLE(this);
};

exports.Table = Table;

},{"./check":2,"./types":25}],11:[function(require,module,exports){
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

'use strict';

var encoding = require('../encoding');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');
var table = require('../table');

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    //var i, objectOffset, endOffset;
    var offsets = [];
    var objects = [];
    var count = parse.getCard16(data, start);
    var i;
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (i = 0; i < offsets.length - 1; i += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value;
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];
        var value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }

        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }

        newDict[m.name] = value;
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var i;
    var sid;
    var count;
    var parser = new parse.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var i;
    var code;
    var enc = {};
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(code, font, index) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new path.Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var width = font.defaultWidthX;
    var open = false;
    var x = 0;
    var y = 0;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
            case 1: // hstem
                parseStems();
                break;
            case 3: // vstem
                parseStems();
                break;
            case 4: // vmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }

                y += stack.pop();
                newContour(x, y);
                break;
            case 5: // rlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }

                break;
            case 6: // hlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }

                    y += stack.shift();
                    p.lineTo(x, y);
                }

                break;
            case 7: // vlineto
                while (stack.length > 0) {
                    y += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }

                    x += stack.shift();
                    p.lineTo(x, y);
                }

                break;
            case 8: // rrcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                break;
            case 10: // callsubr
                codeIndex = stack.pop() + font.subrsBias;
                subrCode = font.subrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }

                break;
            case 11: // return
                return;
            case 12: // flex operators
                v = code[i];
                i += 1;
                switch (v) {
                case 35: // flex
                    // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                    c1x = x   + stack.shift();    // dx1
                    c1y = y   + stack.shift();    // dy1
                    c2x = c1x + stack.shift();    // dx2
                    c2y = c1y + stack.shift();    // dy2
                    jpx = c2x + stack.shift();    // dx3
                    jpy = c2y + stack.shift();    // dy3
                    c3x = jpx + stack.shift();    // dx4
                    c3y = jpy + stack.shift();    // dy4
                    c4x = c3x + stack.shift();    // dx5
                    c4y = c3y + stack.shift();    // dy5
                    x = c4x + stack.shift();      // dx6
                    y = c4y + stack.shift();      // dy6
                    stack.shift();                // flex depth
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                case 34: // hflex
                    // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                    c1x = x   + stack.shift();    // dx1
                    c1y = y;                      // dy1
                    c2x = c1x + stack.shift();    // dx2
                    c2y = c1y + stack.shift();    // dy2
                    jpx = c2x + stack.shift();    // dx3
                    jpy = c2y;                    // dy3
                    c3x = jpx + stack.shift();    // dx4
                    c3y = c2y;                    // dy4
                    c4x = c3x + stack.shift();    // dx5
                    c4y = y;                      // dy5
                    x = c4x + stack.shift();      // dx6
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                case 36: // hflex1
                    // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                    c1x = x   + stack.shift();    // dx1
                    c1y = y   + stack.shift();    // dy1
                    c2x = c1x + stack.shift();    // dx2
                    c2y = c1y + stack.shift();    // dy2
                    jpx = c2x + stack.shift();    // dx3
                    jpy = c2y;                    // dy3
                    c3x = jpx + stack.shift();    // dx4
                    c3y = c2y;                    // dy4
                    c4x = c3x + stack.shift();    // dx5
                    c4y = c3y + stack.shift();    // dy5
                    x = c4x + stack.shift();      // dx6
                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                case 37: // flex1
                    // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                    c1x = x   + stack.shift();    // dx1
                    c1y = y   + stack.shift();    // dy1
                    c2x = c1x + stack.shift();    // dx2
                    c2y = c1y + stack.shift();    // dy2
                    jpx = c2x + stack.shift();    // dx3
                    jpy = c2y + stack.shift();    // dy3
                    c3x = jpx + stack.shift();    // dx4
                    c3y = jpy + stack.shift();    // dy4
                    c4x = c3x + stack.shift();    // dx5
                    c4y = c3y + stack.shift();    // dy5
                    if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                        x = c4x + stack.shift();
                    } else {
                        y = c4y + stack.shift();
                    }

                    p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                    p.curveTo(c3x, c3y, c4x, c4y, x, y);
                    break;
                default:
                    console.log('Glyph ' + index + ': unknown operator ' + 1200 + v);
                    stack.length = 0;
                }
                break;
            case 14: // endchar
                if (stack.length > 0 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }

                if (open) {
                    p.closePath();
                    open = false;
                }

                break;
            case 18: // hstemhm
                parseStems();
                break;
            case 19: // hintmask
            case 20: // cntrmask
                parseStems();
                i += (nStems + 7) >> 3;
                break;
            case 21: // rmoveto
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }

                y += stack.pop();
                x += stack.pop();
                newContour(x, y);
                break;
            case 22: // hmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }

                x += stack.pop();
                newContour(x, y);
                break;
            case 23: // vstemhm
                parseStems();
                break;
            case 24: // rcurveline
                while (stack.length > 2) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
            case 25: // rlinecurve
                while (stack.length > 6) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }

                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
            case 26: // vvcurveto
                if (stack.length % 2) {
                    x += stack.shift();
                }

                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                break;
            case 27: // hhcurveto
                if (stack.length % 2) {
                    y += stack.shift();
                }

                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                break;
            case 28: // shortint
                b1 = code[i];
                b2 = code[i + 1];
                stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                i += 2;
                break;
            case 29: // callgsubr
                codeIndex = stack.pop() + font.gsubrsBias;
                subrCode = font.gsubrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }

                break;
            case 30: // vhcurveto
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }

                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                break;
            case 31: // hvcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }

                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }

                break;
            default:
                if (v < 32) {
                    console.log('Glyph ' + index + ': unknown operator ' + v);
                } else if (v < 247) {
                    stack.push(v - 139);
                } else if (v < 251) {
                    b1 = code[i];
                    i += 1;
                    stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                    b1 = code[i];
                    i += 1;
                    stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                    b1 = code[i];
                    b2 = code[i + 1];
                    b3 = code[i + 2];
                    b4 = code[i + 3];
                    i += 4;
                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                }
            }
        }
    }

    parse(code);
    var glyph = new _glyph.Glyph({font: font, index: index});
    glyph.path = p;
    glyph.advanceWidth = width;
    return glyph;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    var topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    var privateDictOffset = start + topDict['private'][1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = [];
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(parseCFFCharstring(charString, font, i));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid;

    // Is the string in the CFF standard strings?
    var i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new table.Table('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Table('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Table('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Table('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Table('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Table('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Table('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx;
        var dy;
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bézier curves, so convert the quad to a bézier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.

    }

    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Table('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Table('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makePrivateDictIndex(privateDict) {
    var t = new table.Table('Private DICT INDEX', [
        {name: 'privateDicts', type: 'INDEX', value: []}
    ]);
    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'TABLE'},
        {name: 'nameIndex', type: 'TABLE'},
        {name: 'topDictIndex', type: 'TABLE'},
        {name: 'stringIndex', type: 'TABLE'},
        {name: 'globalSubrIndex', type: 'TABLE'},
        {name: 'charsets', type: 'TABLE'},
        {name: 'charStringsIndex', type: 'TABLE'},
        {name: 'privateDictIndex', type: 'TABLE'}
    ]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyphNames.push(glyphs[i].name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    var privateDict = makePrivateDict(privateAttrs, strings);
    t.privateDictIndex = makePrivateDictIndex(privateDict);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;

},{"../encoding":4,"../glyph":6,"../parse":8,"../path":9,"../table":10}],12:[function(require,module,exports){
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var i;
    var cmap = {};
    cmap.version = parse.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = parse.getUShort(data, start + 2);
    var offset = -1;
    for (i = 0; i < cmap.numTables; i += 1) {
        var platformId = parse.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    var p = new parse.Parser(data, start + offset);
    cmap.format = p.parseUShort();
    check.argument(cmap.format === 4, 'Only format 4 cmap tables are supported.');

    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};

    var endCountParser = new parse.Parser(data, start + offset + 14);
    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        var glyphIndex;
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function(a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }

    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;

    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;

},{"../check":2,"../parse":8,"../table":10}],13:[function(require,module,exports){
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

'use strict';

var check = require('../check');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(data, start, index, font) {
    //var p, glyph, flag, i, j, flags,
    //    endPointIndices, numberOfCoordinates, repeatCount, points, point, px, py,
    //    component, moreComponents;
    var p = new parse.Parser(data, start);
    var glyph = new _glyph.Glyph({font: font, index: index});
    glyph.numberOfContours = p.parseShort();
    glyph.xMin = p.parseShort();
    glyph.yMin = p.parseShort();
    glyph.xMax = p.parseShort();
    glyph.yMax = p.parseShort();
    var flags;
    var flag;
    if (glyph.numberOfContours > 0) {
        var i;
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }

        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                component.dx = p.parseShort();
                component.dy = p.parseShort();
            } else {
                // The arguments are bytes
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }

    return glyph;
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new path.Path();
    if (!points) {
        return p;
    }

    var contours = getContours(points);
    for (var i = 0; i < contours.length; i += 1) {
        var contour = contours[i];
        var firstPt = contour[0];
        var lastPt = contour[contour.length - 1];
        var curvePt;
        var realFirstPoint;
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }

            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }

        p.moveTo(firstPt.x, firstPt.y);

        for (var j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            var pt = contour[j];
            var prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                var midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }

        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }

    p.closePath();
    return p;
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = [];
    var i;
    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(parseGlyph(data, start + offset, i, font));
        } else {
            glyphs.push(new _glyph.Glyph({font: font, index: i}));
        }
    }
    // Go over the glyphs again, resolving the composite glyphs.
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        if (glyph.isComposite) {
            for (var j = 0; j < glyph.components.length; j += 1) {
                var component = glyph.components[j];
                var componentGlyph = glyphs[component.glyphIndex];
                if (componentGlyph.points) {
                    var transformedPoints = transformPoints(componentGlyph.points, component);
                    glyph.points = glyph.points.concat(transformedPoints);
                }
            }
        }

        glyph.path = getPath(glyph.points);
    }

    return glyphs;
}

exports.parse = parseGlyfTable;

},{"../check":2,"../glyph":6,"../parse":8,"../path":9}],14:[function(require,module,exports){
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start);
    var n = p.parseUShort();
    var list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }

    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    }
    else if (format === 2) {
        var coverage = [];
        for (; count--;) {
            var begin = p.parseUShort();
            var end = p.parseUShort();
            var index = p.parseUShort();
            for (var i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }

        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort();
        var glyphCount = p.parseUShort();
        var classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    }
    else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort();
        var startGlyphs = [];
        var endGlyphs = [];
        var classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }

        return function(glyphID) {
            var l = 0;
            var r = startGlyphs.length - 1;
            while (l < r) {
                var c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }

            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }

            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    // This part is common to format 1 and format 2 subtables
    var format = p.parseUShort();
    var coverageOffset = p.parseUShort();
    var coverage = parseCoverageTable(data, start + coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    var valueFormat1 = p.parseUShort();
    var valueFormat2 = p.parseUShort();
    var value1;
    var value2;
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    var sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount = p.parseUShort();
        var pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        var pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            var pairSetOffset = pairSetOffsets[firstGlyph];
            var sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                var pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    var secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }

            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }

        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    }
    else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset = p.parseUShort();
        var classDef2Offset = p.parseUShort();
        var class1Count = p.parseUShort();
        var class2Count = p.parseUShort();
        var getClass1 = parseClassDefTable(data, start + classDef1Offset);
        var getClass2 = parseClassDefTable(data, start + classDef2Offset);

        // Parse kerning values by class pair.
        var kerningMatrix = [];
        for (var i = 0; i < class1Count; i++) {
            var kerningRow = kerningMatrix[i] = [];
            for (var j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        var covered = {};
        for (i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return;
            var class1 = getClass1(leftGlyph);
            var class2 = getClass2(rightGlyph);
            var kerningRow = kerningMatrix[class1];

            if (kerningRow) {
                return kerningRow[class2];
            }
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var lookupType = p.parseUShort();
    var lookupFlag = p.parseUShort();
    var useMarkFilteringSet = lookupFlag & 0x10;
    var subTableCount = p.parseUShort();
    var subTableOffsets = p.parseOffset16List(subTableCount);
    var table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        var subtables = [];
        for (var i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }

            return 0;
        };
    }

    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    parseTaggedListTable(data, start + p.parseUShort());
    // 'kern' is the feature we are looking for.
    parseTaggedListTable(data, start + p.parseUShort());

    // LookupList
    var lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    var lookupCount = p.parseUShort();
    var lookupTableOffsets = p.parseOffset16List(lookupCount);
    var lookupListAbsoluteOffset = start + lookupListOffset;
    for (var i = 0; i < lookupCount; i++) {
        var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;

},{"../check":2,"../parse":8}],15:[function(require,module,exports){
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {};
    var p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();     // 50
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: 0},
        {name: 'modified', type: 'LONGDATETIME', value: 0},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;

},{"../check":2,"../parse":8,"../table":10}],16:[function(require,module,exports){
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;

},{"../parse":8,"../table":10}],17:[function(require,module,exports){
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs[i];
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }

    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;

},{"../parse":8,"../table":10}],18:[function(require,module,exports){
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var pairs = {};
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseUShort();
    check.argument(tableVersion === 0, 'Unsupported kern table version.');
    // Skip nTables.
    p.skip('uShort', 1);
    var subTableVersion = p.parseUShort();
    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subTableLength, subTableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }

    return pairs;
}

exports.parse = parseKernTable;

},{"../check":2,"../parse":8}],19:[function(require,module,exports){
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

'use strict';

var parse = require('../parse');

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
}

exports.parse = parseLocaTable;

},{"../parse":8}],20:[function(require,module,exports){
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;

},{"../parse":8,"../table":10}],21:[function(require,module,exports){
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

'use strict';

var encode = require('../types').encode;
var parse = require('../parse');
var table = require('../table');

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'licence',                // 13
    'licenceURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

// Parse the naming `name` table
// Only Windows Unicode English names are supported.
// Format 1 additional fields are not supported
function parseNameTable(data, start) {
    var name = {};
    var p = new parse.Parser(data, start);
    name.format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    var unknownCount = 0;
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID];
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        // platformID - encodingID - languageID standard combinations :
        // 1 - 0 - 0 : Macintosh, Roman, English
        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {
            var codePoints = [];
            var length = byteLength / 2;
            for (var j = 0; j < length; j++, offset += 2) {
                codePoints[j] = parse.getShort(data, stringOffset + offset);
            }

            var str = String.fromCharCode.apply(null, codePoints);
            if (property) {
                name[property] = str;
            }
            else {
                unknownCount++;
                name['unknown' + unknownCount] = str;
            }
        }

    }

    if (name.format === 1) {
        name.langTagCount = p.parseUShort();
    }

    return name;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Table('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

function addMacintoshNameRecord(t, recordID, s, offset) {
    // Macintosh, Roman, English
    var stringBytes = encode.STRING(s);
    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
    t.strings.push(stringBytes);
    offset += stringBytes.length;
    return offset;
}

function addWindowsNameRecord(t, recordID, s, offset) {
    // Windows, Unicode BMP (UCS-2), US English
    var utf16Bytes = encode.UTF16(s);
    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
    t.strings.push(utf16Bytes);
    offset += utf16Bytes.length;
    return offset;
}

function makeNameTable(options) {
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: 0},
        {name: 'stringOffset', type: 'USHORT', value: 0}
    ]);
    t.records = [];
    t.strings = [];
    var offset = 0;
    var i;
    var s;
    // Add Macintosh records first
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addMacintoshNameRecord(t, i, s, offset);
        }
    }
    // Then add Windows records
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addWindowsNameRecord(t, i, s, offset);
        }
    }

    t.count = t.records.length;
    t.stringOffset = 6 + t.count * 12;
    for (i = 0; i < t.records.length; i += 1) {
        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});
    }

    for (i = 0; i < t.strings.length; i += 1) {
        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});
    }

    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;

},{"../parse":8,"../table":10,"../types":25}],22:[function(require,module,exports){
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

var unicodeRanges = [
    {begin: 0x0000, end: 0x007F}, // Basic Latin
    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
    {begin: 0x2C80, end: 0x2CFF}, // Coptic
    {begin: 0x0400, end: 0x04FF}, // Cyrillic
    {begin: 0x0530, end: 0x058F}, // Armenian
    {begin: 0x0590, end: 0x05FF}, // Hebrew
    {begin: 0xA500, end: 0xA63F}, // Vai
    {begin: 0x0600, end: 0x06FF}, // Arabic
    {begin: 0x07C0, end: 0x07FF}, // NKo
    {begin: 0x0900, end: 0x097F}, // Devanagari
    {begin: 0x0980, end: 0x09FF}, // Bengali
    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
    {begin: 0x0B00, end: 0x0B7F}, // Oriya
    {begin: 0x0B80, end: 0x0BFF}, // Tamil
    {begin: 0x0C00, end: 0x0C7F}, // Telugu
    {begin: 0x0C80, end: 0x0CFF}, // Kannada
    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
    {begin: 0x0E00, end: 0x0E7F}, // Thai
    {begin: 0x0E80, end: 0x0EFF}, // Lao
    {begin: 0x10A0, end: 0x10FF}, // Georgian
    {begin: 0x1B00, end: 0x1B7F}, // Balinese
    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
    {begin: 0x2000, end: 0x206F}, // General Punctuation
    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
    {begin: 0x2150, end: 0x218F}, // Number Forms
    {begin: 0x2190, end: 0x21FF}, // Arrows
    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
    {begin: 0x2400, end: 0x243F}, // Control Pictures
    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
    {begin: 0x2500, end: 0x257F}, // Box Drawing
    {begin: 0x2580, end: 0x259F}, // Block Elements
    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
    {begin: 0x2700, end: 0x27BF}, // Dingbats
    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
    {begin: 0x3040, end: 0x309F}, // Hiragana
    {begin: 0x30A0, end: 0x30FF}, // Katakana
    {begin: 0x3100, end: 0x312F}, // Bopomofo
    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
    {begin: 0xA840, end: 0xA87F}, // Phags-pa
    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
    {begin: 0x10900, end: 0x1091F}, // Phoenicia
    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
    {begin: 0xFFF0, end: 0xFFFF}, // Specials
    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
    {begin: 0x0700, end: 0x074F}, // Syriac
    {begin: 0x0780, end: 0x07BF}, // Thaana
    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
    {begin: 0x1000, end: 0x109F}, // Myanmar
    {begin: 0x1200, end: 0x137F}, // Ethiopic
    {begin: 0x13A0, end: 0x13FF}, // Cherokee
    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
    {begin: 0x1680, end: 0x169F}, // Ogham
    {begin: 0x16A0, end: 0x16FF}, // Runic
    {begin: 0x1780, end: 0x17FF}, // Khmer
    {begin: 0x1800, end: 0x18AF}, // Mongolian
    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
    {begin: 0x1700, end: 0x171F}, // Tagalog
    {begin: 0x10300, end: 0x1032F}, // Old Italic
    {begin: 0x10330, end: 0x1034F}, // Gothic
    {begin: 0x10400, end: 0x1044F}, // Deseret
    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
    {begin: 0xE0000, end: 0xE007F}, // Tags
    {begin: 0x1900, end: 0x194F}, // Limbu
    {begin: 0x1950, end: 0x197F}, // Tai Le
    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
    {begin: 0x1A00, end: 0x1A1F}, // Buginese
    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
    {begin: 0x10380, end: 0x1039F}, // Ugaritic
    {begin: 0x103A0, end: 0x103DF}, // Old Persian
    {begin: 0x10450, end: 0x1047F}, // Shavian
    {begin: 0x10480, end: 0x104AF}, // Osmanya
    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
    {begin: 0x12000, end: 0x123FF}, // Cuneiform
    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
    {begin: 0xA900, end: 0xA92F}, // Kayah Li
    {begin: 0xA930, end: 0xA95F}, // Rejang
    {begin: 0xAA00, end: 0xAA5F}, // Cham
    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
    {begin: 0x102A0, end: 0x102DF}, // Carian
    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.unicodeRanges = unicodeRanges;
exports.getUnicodeRange = getUnicodeRange;
exports.parse = parseOS2Table;
exports.make = makeOS2Table;

},{"../parse":8,"../table":10}],23:[function(require,module,exports){
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

'use strict';

var encoding = require('../encoding');
var parse = require('../parse');
var table = require('../table');

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {};
    var p = new parse.Parser(data, start);
    var i;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
    case 1:
        post.names = encoding.standardNames.slice();
        break;
    case 2:
        post.numberOfGlyphs = p.parseUShort();
        post.glyphNameIndex = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.glyphNameIndex[i] = p.parseUShort();
        }

        post.names = [];
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                var nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
        }

        break;
    case 2.5:
        post.numberOfGlyphs = p.parseUShort();
        post.offset = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.offset[i] = p.parseChar();
        }

        break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;

},{"../encoding":4,"../parse":8,"../table":10}],24:[function(require,module,exports){
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

'use strict';

var check = require('../check');
var table = require('../table');

var cmap = require('./cmap');
var cff = require('./cff');
var head = require('./head');
var hhea = require('./hhea');
var hmtx = require('./hmtx');
var maxp = require('./maxp');
var _name = require('./name');
var os2 = require('./os2');
var post = require('./post');

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Table('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs[glyphIndex];
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex = null;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs[i];
        var unicode = glyph.unicode | 0;
        if (firstCharIndex > unicode || firstCharIndex === null) {
            firstCharIndex = unicode;
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender !== undefined ? font.ascender : globals.yMax;
    globals.descender = font.descender !== undefined ? font.descender : globals.yMin;

    var headTable = head.make({
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax
    });

    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: 500, // Medium FIXME Make this configurable
        usWidthClass: 5, // Medium (normal) FIXME Make this configurable
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.ascender,
        usWinDescent: -globals.descender,
        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var fullName = font.familyName + ' ' + font.styleName;
    var postScriptName = font.familyName.replace(/\s/g, '') + '-' + font.styleName;
    var nameTable = _name.make({
        copyright: font.copyright,
        fontFamily: font.familyName,
        fontSubfamily: font.styleName,
        uniqueID: font.manufacturer + ':' + fullName,
        fullName: fullName,
        version: font.version,
        postScriptName: postScriptName,
        trademark: font.trademark,
        manufacturer: font.manufacturer,
        designer: font.designer,
        description: font.description,
        manufacturerURL: font.manufacturerURL,
        designerURL: font.designerURL,
        license: font.license,
        licenseURL: font.licenseURL,
        preferredFamily: font.familyName,
        preferredSubfamily: font.styleName
    });
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.version,
        fullName: fullName,
        familyName: font.familyName,
        weightName: font.styleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm
    });
    // Order the tables according to the the OpenType specification 1.4.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (i = 0; i < tableFields.length; i += 1) {
        if (tableFields[i].name === 'head table') {
            tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;

},{"../check":2,"../table":10,"./cff":11,"./cmap":12,"./head":15,"./hhea":16,"./hmtx":17,"./maxp":20,"./name":21,"./os2":22,"./post":23}],25:[function(require,module,exports){
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

/* global WeakMap */

'use strict';

var check = require('./check');

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

var decode = {};
var encode = {};
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

// Convert an 8-bit unsigned integer to a list of 1 byte.
encode.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};

sizeOf.BYTE = constant(1);

// Convert a 8-bit signed integer to a list of 1 byte.
encode.CHAR = function(v) {
    return [v.charCodeAt(0)];
};

sizeOf.BYTE = constant(1);

// Convert an ASCII string to a list of bytes.
encode.CHARARRAY = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(v.charCodeAt(i));
    }

    return b;
};

sizeOf.CHARARRAY = function(v) {
    return v.length;
};

// Convert a 16-bit unsigned integer to a list of 2 bytes.
encode.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.USHORT = constant(2);

// Convert a 16-bit signed integer to a list of 2 bytes.
encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.SHORT = constant(2);

// Convert a 24-bit unsigned integer to a list of 3 bytes.
encode.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.UINT24 = constant(3);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.ULONG = constant(4);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

// FIXME Implement LONGDATETIME
encode.LONGDATETIME = function() {
    return [0, 0, 0, 0, 0, 0, 0, 0];
};

sizeOf.LONGDATETIME = constant(8);

// Convert a 4-char tag to a list of 4 bytes.
encode.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};

// Convert a signed number between -32768 and +32767 to a three-byte value.
// This ensures we always use three bytes, but is not the most compact format.
encode.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER16 = constant(2);

// Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
// This is useful if you want to be sure you always use four bytes,
// at the expense of wasting a few bytes for smaller numbers.
encode.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER32 = constant(4);

encode.REAL = function(v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    var i;
    var ii;
    for (i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (i = 0, ii = nibbles.length; i < ii; i += 2) {
        out.push(parseInt(nibbles.substr(i, 2), 16));
    }

    return out;
};

sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

// Convert a ASCII string to a list of UTF16 bytes.
encode.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(0);
        b.push(v.charCodeAt(i));
    }

    return b;
};

sizeOf.UTF16 = function(v) {
    return v.length * 2;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
encode.INDEX = function(l) {
    var i;
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    dataSize, i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    var dataSize = 0;
    for (i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        dataSize += v.length;
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(dataSize) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        var encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};

// Convert an object to a CFF DICT structure.
// The keys should be numeric.
// The values should be objects containing name / type / value.
encode.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};

encode.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

encode.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();
// Convert a list of CharString operations to bytes.
encode.CHARSTRING = function(ops) {
    if (wmm && wmm.has(ops)) {
        return wmm.get(ops);
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

// Convert an object containing name / type / value to bytes.
encode.OBJECT = function(v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

// Convert a table object to bytes.
// A table contains a list of fields containing the metadata (name, type and default value).
// The table itself has the field values set as attributes.
encode.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);
        d = d.concat(bytes);
    }

    return d;
};

// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};

sizeOf.LITERAL = function(v) {
    return v.length;
};

exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

},{"./check":2}]},{},[7])(7)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwic3JjL2NoZWNrLmpzIiwic3JjL2RyYXcuanMiLCJzcmMvZW5jb2RpbmcuanMiLCJzcmMvZm9udC5qcyIsInNyYy9nbHlwaC5qcyIsInNyYy9vcGVudHlwZS5qcyIsInNyYy9wYXJzZS5qcyIsInNyYy9wYXRoLmpzIiwic3JjL3RhYmxlLmpzIiwic3JjL3RhYmxlcy9jZmYuanMiLCJzcmMvdGFibGVzL2NtYXAuanMiLCJzcmMvdGFibGVzL2dseWYuanMiLCJzcmMvdGFibGVzL2dwb3MuanMiLCJzcmMvdGFibGVzL2hlYWQuanMiLCJzcmMvdGFibGVzL2hoZWEuanMiLCJzcmMvdGFibGVzL2htdHguanMiLCJzcmMvdGFibGVzL2tlcm4uanMiLCJzcmMvdGFibGVzL2xvY2EuanMiLCJzcmMvdGFibGVzL21heHAuanMiLCJzcmMvdGFibGVzL25hbWUuanMiLCJzcmMvdGFibGVzL29zMi5qcyIsInNyYy90YWJsZXMvcG9zdC5qcyIsInNyYy90YWJsZXMvc2ZudC5qcyIsInNyYy90eXBlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hcmd1bWVudCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmFyZ3VtZW50O1xuIiwiLy8gRHJhd2luZyB1dGlsaXR5IGZ1bmN0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEcmF3IGEgbGluZSBvbiB0aGUgZ2l2ZW4gY29udGV4dCBmcm9tIHBvaW50IGB4MSx5MWAgdG8gcG9pbnQgYHgyLHkyYC5cbmZ1bmN0aW9uIGxpbmUoY3R4LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbn1cblxuZXhwb3J0cy5saW5lID0gbGluZTtcbiIsIi8vIEdseXBoIGVuY29kaW5nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJycsICdwYXJhZ3JhcGgnLCAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG4gICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnQUUnLCAnJywgJ29yZGZlbWluaW5lJywgJycsICcnLCAnJyxcbiAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG4gICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICd0d29kb3RlbmxlYWRlcicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuICAgICdzZW1pY29sb24nLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJywgJ3F1ZXN0aW9uc21hbGwnLCAnJywgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICcnLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsICcnLCAnRG90YWNjZW50c21hbGwnLCAnJywgJycsICdNYWNyb25zbWFsbCcsICcnLCAnJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcbiAgICAnJywgJ3plcm9zdXBlcmlvcicsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJywgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLCAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxudmFyIHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLy8gVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG4vLyBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuLy8gU2luY2UgaXQncyBsaW5lYXIgdGltZSwgb3RoZXIgZW5jb2RpbmdzIHdpbGwgYmUgZmFzdGVyLlxuZnVuY3Rpb24gRGVmYXVsdEVuY29kaW5nKGZvbnQpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xufVxuXG5EZWZhdWx0RW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHM7XG4gICAgaWYgKGdseXBocykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jaGFyQ29kZUF0KDApXSB8fCAwO1xufTtcblxuZnVuY3Rpb24gQ2ZmRW5jb2RpbmcoZW5jb2RpbmcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbn1cblxuQ2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGNvZGUgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xufTtcblxuZnVuY3Rpb24gR2x5cGhOYW1lcyhwb3N0KSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMubmFtZXMgPSBleHBvcnRzLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IGV4cG9ydHMuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gcG9zdC5uYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldIC0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLmxlbmd0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDIuNTpcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IGV4cG9ydHMuc3RhbmRhcmROYW1lc1tpICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzLmluZGV4T2YobmFtZSk7XG59O1xuXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNbZ2lkXTtcbn07XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCkge1xuICAgIHZhciBnbHlwaDtcbiAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgZ2x5cGguYWRkVW5pY29kZShwYXJzZUludChjKSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHNbaV07XG4gICAgICAgIGlmIChmb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmNmZlN0YW5kYXJkU3RyaW5ncyA9IGNmZlN0YW5kYXJkU3RyaW5ncztcbmV4cG9ydHMuY2ZmU3RhbmRhcmRFbmNvZGluZyA9IGNmZlN0YW5kYXJkRW5jb2Rpbmc7XG5leHBvcnRzLmNmZkV4cGVydEVuY29kaW5nID0gY2ZmRXhwZXJ0RW5jb2Rpbmc7XG5leHBvcnRzLnN0YW5kYXJkTmFtZXMgPSBzdGFuZGFyZE5hbWVzO1xuZXhwb3J0cy5EZWZhdWx0RW5jb2RpbmcgPSBEZWZhdWx0RW5jb2Rpbmc7XG5leHBvcnRzLkNtYXBFbmNvZGluZyA9IENtYXBFbmNvZGluZztcbmV4cG9ydHMuQ2ZmRW5jb2RpbmcgPSBDZmZFbmNvZGluZztcbmV4cG9ydHMuR2x5cGhOYW1lcyA9IEdseXBoTmFtZXM7XG5leHBvcnRzLmFkZEdseXBoTmFtZXMgPSBhZGRHbHlwaE5hbWVzO1xuIiwiLy8gVGhlIEZvbnQgb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcbnZhciBzZm50ID0gcmVxdWlyZSgnLi90YWJsZXMvc2ZudCcpO1xudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xuXG4vLyBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4vLyBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuLy8gb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG5mdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuICAgIHRoaXMuZmFtaWx5TmFtZSA9IG9wdGlvbnMuZmFtaWx5TmFtZSB8fCAnICc7XG4gICAgdGhpcy5zdHlsZU5hbWUgPSBvcHRpb25zLnN0eWxlTmFtZSB8fCAnICc7XG4gICAgdGhpcy5kZXNpZ25lciA9IG9wdGlvbnMuZGVzaWduZXIgfHwgJyAnO1xuICAgIHRoaXMuZGVzaWduZXJVUkwgPSBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJztcbiAgICB0aGlzLm1hbnVmYWN0dXJlciA9IG9wdGlvbnMubWFudWZhY3R1cmVyIHx8ICcgJztcbiAgICB0aGlzLm1hbnVmYWN0dXJlclVSTCA9IG9wdGlvbnMubWFudWZhY3R1cmVyVVJMIHx8ICcgJztcbiAgICB0aGlzLmxpY2Vuc2UgPSBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnO1xuICAgIHRoaXMubGljZW5zZVVSTCA9IG9wdGlvbnMubGljZW5zZVVSTCB8fCAnICc7XG4gICAgdGhpcy52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uIHx8ICdWZXJzaW9uIDAuMSc7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnO1xuICAgIHRoaXMuY29weXJpZ2h0ID0gb3B0aW9ucy5jb3B5cmlnaHQgfHwgJyAnO1xuICAgIHRoaXMudHJhZGVtYXJrID0gb3B0aW9ucy50cmFkZW1hcmsgfHwgJyAnO1xuICAgIHRoaXMudW5pdHNQZXJFbSA9IG9wdGlvbnMudW5pdHNQZXJFbSB8fCAxMDAwO1xuICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2x5cGhzID0gb3B0aW9ucy5nbHlwaHMgfHwgW107XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5EZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy50YWJsZXMgPSB7fTtcbn1cblxuLy8gQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuLy8gdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChzKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuLy8gdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2dseXBoSW5kZXhdO1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gLm5vdGRlZlxuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdpdmVuIHRleHQgdG8gYSBsaXN0IG9mIEdseXBoIG9iamVjdHMuXG4vLyBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gc3RyaWN0IG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kXG4vLyBnbHlwaHMsIHNvIHRoZSBsaXN0IG9mIHJldHVybmVkIGdseXBocyBjYW4gYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGdseXBocyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHNbaV07XG4gICAgICAgIGdseXBocy5wdXNoKHRoaXMuY2hhclRvR2x5cGgoYykpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbn07XG5cbkZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5uYW1ldG9HbHlwaEluZGV4KG5hbWUpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2dseXBoSW5kZXhdO1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gLm5vdGRlZlxuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbkZvbnQucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoZ2lkKTtcbn07XG5cbi8vIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbi8vIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4vLyBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbi8vIGJldHdlZW4gZ2x5cGhzLlxuRm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMuZ2V0R3Bvc0tlcm5pbmdWYWx1ZTtcbiAgICByZXR1cm4gZ3Bvc0tlcm5pbmcgPyBncG9zS2VybmluZyhsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIDpcbiAgICAgICAgKHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDApO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG4vLyBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLlxuRm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBrZXJuaW5nID0gb3B0aW9ucy5rZXJuaW5nID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5rZXJuaW5nO1xuICAgIHZhciBmb250U2NhbGUgPSAxIC8gdGhpcy51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgdmFyIGdseXBocyA9IHRoaXMuc3RyaW5nVG9HbHlwaHModGV4dCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjayhnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXJuaW5nICYmIGkgPCBnbHlwaHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIGtlcm5pbmdWYWx1ZSA9IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuLy9cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuLy9cbi8vIFJldHVybnMgYSBQYXRoIG9iamVjdC5cbkZvbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBmdWxsUGF0aCA9IG5ldyBwYXRoLlBhdGgoKTtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplKTtcbiAgICAgICAgZnVsbFBhdGguZXh0ZW5kKGdseXBoUGF0aCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vLyBEcmF3IHRoZSB0ZXh0IG9uIHRoZSBnaXZlbiBkcmF3aW5nIGNvbnRleHQuXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLy8gRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuRm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdQb2ludHMoY3R4LCBnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vLyBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuLy8gQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4vLyBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4vLyBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdNZXRyaWNzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLy8gVmFsaWRhdGVcbkZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgICAgICAgYXNzZXJ0KF90aGlzW2F0dHJOYW1lXSAmJiBfdGhpc1thdHRyTmFtZV0udHJpbSgpLmxlbmd0aCA+IDAsICdObyAnICsgYXR0ck5hbWUgKyAnIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnZmFtaWx5TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnbWFudWZhY3R1cmVyJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdjb3B5cmlnaHQnKTtcbiAgICBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwLCAnTm8gdW5pdHNQZXJFbSBzcGVjaWZpZWQuJyk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG4vLyBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuXG5Gb250LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZm50VGFibGUgPSB0aGlzLnRvVGFibGVzKCk7XG4gICAgdmFyIGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgICB2YXIgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW50QXJyYXlbaV0gPSBieXRlc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbkZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gdGhpcy5mYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyB0aGlzLnN0eWxlTmFtZSArICcub3RmJztcbiAgICB2YXIgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuXG4gICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0od2luZG93LlRFTVBPUkFSWSwgYnVmZmVyLmJ5dGVMZW5ndGgsIGZ1bmN0aW9uKGZzKSB7XG4gICAgICAgIGZzLnJvb3QuZ2V0RmlsZShmaWxlTmFtZSwge2NyZWF0ZTogdHJ1ZX0sIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgZmlsZUVudHJ5LmNyZWF0ZVdyaXRlcihmdW5jdGlvbih3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoYmxvYik7XG5cbiAgICAgICAgICAgICAgICB3cml0ZXIuYWRkRXZlbnRMaXN0ZW5lcignd3JpdGVlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGluZyB0byB0aGUgZmlsZSB3aWxsIGRvd25sb2FkIGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufTtcblxuZXhwb3J0cy5Gb250ID0gRm9udDtcbiIsIi8vIFRoZSBHbHlwaCBvYmplY3RcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG52YXIgZHJhdyA9IHJlcXVpcmUoJy4vZHJhdycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG5mdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgdGhpcy5mb250ID0gb3B0aW9ucy5mb250IHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcbiAgICB0aGlzLnhNaW4gPSBvcHRpb25zLnhNaW4gfHwgMDtcbiAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW4gfHwgMDtcbiAgICB0aGlzLnhNYXggPSBvcHRpb25zLnhNYXggfHwgMDtcbiAgICB0aGlzLnlNYXggPSBvcHRpb25zLnlNYXggfHwgMDtcbiAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8IG51bGw7XG59XG5cbkdseXBoLnByb3RvdHlwZS5hZGRVbmljb2RlID0gZnVuY3Rpb24odW5pY29kZSkge1xuICAgIGlmICh0aGlzLnVuaWNvZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnVuaWNvZGUgPSB1bmljb2RlO1xuICAgIH1cblxuICAgIHRoaXMudW5pY29kZXMucHVzaCh1bmljb2RlKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdseXBoIHRvIGEgUGF0aCB3ZSBjYW4gZHJhdyBvbiBhIGRyYXdpbmcgY29udGV4dC5cbi8vXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHgsIHksIGZvbnRTaXplKSB7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIHZhciBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBwLmxpbmVUbyh4ICsgKGNtZC54ICogc2NhbGUpLCB5ICsgKC1jbWQueSAqIHNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogc2NhbGUpLCB5ICsgKC1jbWQueTEgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHAuY3VydmVUbyh4ICsgKGNtZC54MSAqIHNjYWxlKSwgeSArICgtY21kLnkxICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogc2NhbGUpLCB5ICsgKC1jbWQueTIgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8vIFNwbGl0IHRoZSBnbHlwaCBpbnRvIGNvbnRvdXJzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHRvXG4vLyBwcm92aWRlIHJhdyBhY2Nlc3MgdG8gdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmVzLlxuR2x5cGgucHJvdG90eXBlLmdldENvbnRvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vLyBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IDBcbiAgICB9O1xuICAgIG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyA9IHRoaXMuYWR2YW5jZVdpZHRoIC0gbWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcgLSAobWV0cmljcy54TWF4IC0gbWV0cmljcy54TWluKTtcbiAgICByZXR1cm4gbWV0cmljcztcbn07XG5cbi8vIERyYXcgdGhlIGdseXBoIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuLy9cbi8vIGN0eCAtIFRoZSBkcmF3aW5nIGNvbnRleHQuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB0aGlzLmdldFBhdGgoeCwgeSwgZm9udFNpemUpLmRyYXcoY3R4KTtcbn07XG5cbi8vIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIFRoZSBkcmF3aW5nIGNvbnRleHQuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblxuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIHZhciBQSV9TUSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSksIDIsIDAsIFBJX1NRLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgdmFyIGJsdWVDaXJjbGVzID0gW107XG4gICAgdmFyIHJlZENpcmNsZXMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibHVlQ2lyY2xlcy5wdXNoKHt4OiBjbWQueCwgeTogLWNtZC55fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8vIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMuXG4vLyBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbi8vIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbi8vIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbi8vXG4vLyBjdHggLSBUaGUgZHJhd2luZyBjb250ZXh0LlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUsIGluIHBpeGVscyAoZGVmYXVsdDogNzIpLlxuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIHZhciBzY2FsZTtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG5cbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpLCAxMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSk7XG5cbiAgICAvLyBEcmF3IHRoZSBhZHZhbmNlIHdpZHRoXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHRoaXMuYWR2YW5jZVdpZHRoICogc2NhbGUpLCAtMTAwMDAsIHggKyAodGhpcy5hZHZhbmNlV2lkdGggKiBzY2FsZSksIDEwMDAwKTtcbn07XG5cbmV4cG9ydHMuR2x5cGggPSBHbHlwaDtcbiIsIi8vIG9wZW50eXBlLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWJveC9vcGVudHlwZS5qc1xuLy8gKGMpIDIwMTQgRnJlZGVyaWsgRGUgQmxlc2VyXG4vLyBvcGVudHlwZS5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuLyogZ2xvYmFsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVWludDhBcnJheSwgWE1MSHR0cFJlcXVlc3QgICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xudmFyIF9mb250ID0gcmVxdWlyZSgnLi9mb250Jyk7XG52YXIgZ2x5cGggPSByZXF1aXJlKCcuL2dseXBoJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG52YXIgY21hcCA9IHJlcXVpcmUoJy4vdGFibGVzL2NtYXAnKTtcbnZhciBjZmYgPSByZXF1aXJlKCcuL3RhYmxlcy9jZmYnKTtcbnZhciBnbHlmID0gcmVxdWlyZSgnLi90YWJsZXMvZ2x5ZicpO1xudmFyIGdwb3MgPSByZXF1aXJlKCcuL3RhYmxlcy9ncG9zJyk7XG52YXIgaGVhZCA9IHJlcXVpcmUoJy4vdGFibGVzL2hlYWQnKTtcbnZhciBoaGVhID0gcmVxdWlyZSgnLi90YWJsZXMvaGhlYScpO1xudmFyIGhtdHggPSByZXF1aXJlKCcuL3RhYmxlcy9obXR4Jyk7XG52YXIga2VybiA9IHJlcXVpcmUoJy4vdGFibGVzL2tlcm4nKTtcbnZhciBsb2NhID0gcmVxdWlyZSgnLi90YWJsZXMvbG9jYScpO1xudmFyIG1heHAgPSByZXF1aXJlKCcuL3RhYmxlcy9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL3RhYmxlcy9uYW1lJyk7XG52YXIgb3MyID0gcmVxdWlyZSgnLi90YWJsZXMvb3MyJyk7XG52YXIgcG9zdCA9IHJlcXVpcmUoJy4vdGFibGVzL3Bvc3QnKTtcblxuLy8gRmlsZSBsb2FkZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGEgTm9kZS5qcyBCdWZmZXIgdG8gYW4gQXJyYXlCdWZmZXJcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGFbaV0gPSBidWZmZXJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xufVxuXG5mdW5jdGlvbiBsb2FkRnJvbUZpbGUocGF0aCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgYnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB0b0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkRnJvbVVybCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZDogJyArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVxdWVzdC5yZXNwb25zZSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4vLyBJZiB0aGUgZmlsZSBjb3VsZCBub3QgYmUgcGFyc2VkIChtb3N0IGxpa2VseSBiZWNhdXNlIGl0IGNvbnRhaW5zIFBvc3RzY3JpcHQgb3V0bGluZXMpXG4vLyB3ZSByZXR1cm4gYW4gZW1wdHkgRm9udCBvYmplY3Qgd2l0aCB0aGUgYHN1cHBvcnRlZGAgZmxhZyBzZXQgdG8gYGZhbHNlYC5cbmZ1bmN0aW9uIHBhcnNlQnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBpbmRleFRvTG9jRm9ybWF0O1xuICAgIHZhciBobXR4T2Zmc2V0O1xuICAgIHZhciBnbHlmT2Zmc2V0O1xuICAgIHZhciBsb2NhT2Zmc2V0O1xuICAgIHZhciBjZmZPZmZzZXQ7XG4gICAgdmFyIGtlcm5PZmZzZXQ7XG4gICAgdmFyIGdwb3NPZmZzZXQ7XG5cbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cblxuICAgIHZhciBmb250ID0gbmV3IF9mb250LkZvbnQoKTtcbiAgICB2YXIgZGF0YSA9IG5ldyBEYXRhVmlldyhidWZmZXIsIDApO1xuXG4gICAgdmFyIHZlcnNpb24gPSBwYXJzZS5nZXRGaXhlZChkYXRhLCAwKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgdmVyc2lvbiAnICsgdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuXG4gICAgLy8gT2Zmc2V0IGludG8gdGhlIHRhYmxlIHJlY29yZHMuXG4gICAgdmFyIHAgPSAxMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgJ2NtYXAnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMuY21hcCA9IGNtYXAucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ21hcEVuY29kaW5nKGZvbnQudGFibGVzLmNtYXApO1xuICAgICAgICAgICAgaWYgKCFmb250LmVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgZm9udC5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgaG10eE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmZhbWlseU5hbWUgPSBmb250LnRhYmxlcy5uYW1lLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBmb250LnN0eWxlTmFtZSA9IGZvbnQudGFibGVzLm5hbWUuZm9udFN1YmZhbWlseTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBlbmNvZGluZy5HbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgZ2x5Zk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgIGxvY2FPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ0ZGICc6XG4gICAgICAgICAgICBjZmZPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICBrZXJuT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgZ3Bvc09mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgaWYgKGdseWZPZmZzZXQgJiYgbG9jYU9mZnNldCkge1xuICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgdmFyIGxvY2FUYWJsZSA9IGxvY2EucGFyc2UoZGF0YSwgbG9jYU9mZnNldCwgZm9udC5udW1HbHlwaHMsIHNob3J0VmVyc2lvbik7XG4gICAgICAgIGZvbnQuZ2x5cGhzID0gZ2x5Zi5wYXJzZShkYXRhLCBnbHlmT2Zmc2V0LCBsb2NhVGFibGUsIGZvbnQpO1xuICAgICAgICBobXR4LnBhcnNlKGRhdGEsIGhtdHhPZmZzZXQsIGZvbnQubnVtYmVyT2ZITWV0cmljcywgZm9udC5udW1HbHlwaHMsIGZvbnQuZ2x5cGhzKTtcbiAgICAgICAgZW5jb2RpbmcuYWRkR2x5cGhOYW1lcyhmb250KTtcbiAgICB9IGVsc2UgaWYgKGNmZk9mZnNldCkge1xuICAgICAgICBjZmYucGFyc2UoZGF0YSwgY2ZmT2Zmc2V0LCBmb250KTtcbiAgICAgICAgZW5jb2RpbmcuYWRkR2x5cGhOYW1lcyhmb250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb250LnN1cHBvcnRlZCkge1xuICAgICAgICBpZiAoa2Vybk9mZnNldCkge1xuICAgICAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGRhdGEsIGtlcm5PZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChncG9zT2Zmc2V0KSB7XG4gICAgICAgICAgICBncG9zLnBhcnNlKGRhdGEsIGdwb3NPZmZzZXQsIGZvbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcbi8vIHdpdGggdHdvIGFyZ3VtZW50cyBgKGVyciwgZm9udClgLiBUaGUgYGVycmAgd2lsbCBiZSBudWxsIG9uIHN1Y2Nlc3MsXG4vLyB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG4vL1xuLy8gV2UgdXNlIHRoZSBub2RlLmpzIGNhbGxiYWNrIGNvbnZlbnRpb24gc28gdGhhdFxuLy8gb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cbmZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICB2YXIgbG9hZEZuID0gaXNOb2RlID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG4gICAgbG9hZEZuKHVybCwgZnVuY3Rpb24oZXJyLCBhcnJheUJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb250ID0gcGFyc2VCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgICBpZiAoIWZvbnQuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgaXMgbm90IHN1cHBvcnRlZCAoaXMgdGhpcyBhIFBvc3RzY3JpcHQgZm9udD8pJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuX3BhcnNlID0gcGFyc2U7XG5leHBvcnRzLkZvbnQgPSBfZm9udC5Gb250O1xuZXhwb3J0cy5HbHlwaCA9IGdseXBoLkdseXBoO1xuZXhwb3J0cy5QYXRoID0gcGF0aC5QYXRoO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlQnVmZmVyO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbiIsIi8vIFBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuZXhwb3J0cy5nZXRCeXRlID0gZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59O1xuXG5leHBvcnRzLmdldENhcmQ4ID0gZXhwb3J0cy5nZXRCeXRlO1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFVTaG9ydCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufTtcblxuZXhwb3J0cy5nZXRDYXJkMTYgPSBleHBvcnRzLmdldFVTaG9ydDtcblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRTaG9ydCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG59O1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0VUxvbmcgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbn07XG5cbi8vIFJldHJpZXZlIGEgMzItYml0IHNpZ25lZCBmaXhlZC1wb2ludCBudW1iZXIgKDE2LjE2KSBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0Rml4ZWQgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICB2YXIgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn07XG5cbi8vIFJldHJpZXZlIGEgNC1jaGFyYWN0ZXIgdGFnIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5leHBvcnRzLmdldFRhZyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgdGFnID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDQ7IGkgKz0gMSkge1xuICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRJbnQ4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnO1xufTtcblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZXhwb3J0cy5nZXRPZmZzZXQgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIHYgPDw9IDg7XG4gICAgICAgIHYgKz0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbmV4cG9ydHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbn07XG5cbi8vIENvbnZlcnQgdGhlIGxpc3Qgb2YgYnl0ZXMgdG8gYSBzdHJpbmcuXG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBmdW5jdGlvbihieXRlcykge1xuICAgIHZhciBzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufTtcblxudmFyIHR5cGVPZmZzZXRzID0ge1xuICAgIGJ5dGU6IDEsXG4gICAgdVNob3J0OiAyLFxuICAgIHNob3J0OiAyLFxuICAgIHVMb25nOiA0LFxuICAgIGZpeGVkOiA0LFxuICAgIGxvbmdEYXRlVGltZTogOCxcbiAgICB0YWc6IDRcbn07XG5cbi8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuLy8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cbmZ1bmN0aW9uIFBhcnNlcihkYXRhLCBvZmZzZXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCkgLyAxNjM4NDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGV4cG9ydHMuZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2ldID0gZXhwb3J0cy5nZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBvZmZzZXRzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdHJpbmcgPSAnJztcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xufTtcblxuLy8gTE9OR0RBVEVUSU1FIGlzIGEgNjQtYml0IGludGVnZXIuXG4vLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2Vcbi8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2IC8gNjU1MzY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYWpvciA9IGV4cG9ydHMuZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gVGhpcyByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGV4cG9ydHMuZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gMHgxMDAwIC8gMTA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih0eXBlLCBhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xufTtcblxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4iLCIvLyBHZW9tZXRyaWMgb2JqZWN0c1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIEEgYsOpemllciBwYXRoIGNvbnRhaW5pbmcgYSBzZXQgb2YgcGF0aCBjb21tYW5kcyBzaW1pbGFyIHRvIGEgU1ZHIHBhdGguXG4vLyBQYXRocyBjYW4gYmUgZHJhd24gb24gYSBjb250ZXh0IHVzaW5nIGBkcmF3YC5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgdGhpcy5zdHJva2UgPSBudWxsO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xufVxuXG5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0wnLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cblBhdGgucHJvdG90eXBlLnF1YWRUbyA9IFBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnUScsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJ1xuICAgIH0pO1xufTtcblxuLy8gQWRkIHRoZSBnaXZlbiBwYXRoIG9yIGxpc3Qgb2YgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9mIHRoaXMgcGF0aC5cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhdGhPckNvbW1hbmRzKSB7XG4gICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG4gICAgICAgIHBhdGhPckNvbW1hbmRzID0gcGF0aE9yQ29tbWFuZHMuY29tbWFuZHM7XG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLy8gRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbDtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGRlY2ltYWxQbGFjZXM6IFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlcyAoZGVmYXVsdDogMilcblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG4gICAgZnVuY3Rpb24gZmxvYXRUb1N0cmluZyh2KSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHYpID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhY2tWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDAgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyArPSBmbG9hdFRvU3RyaW5nKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLy8gQ29udmVydCB0aGUgcGF0aCB0byBhIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBkZWNpbWFsUGxhY2VzOiBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXMgKGRlZmF1bHQ6IDIpXG5QYXRoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgc3ZnID0gJzxwYXRoIGQ9XCInO1xuICAgIHN2ZyArPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG4gICAgc3ZnICs9ICdcIic7XG4gICAgaWYgKHRoaXMuZmlsbCAmIHRoaXMuZmlsbCAhPT0gJ2JsYWNrJykge1xuICAgICAgICBpZiAodGhpcy5maWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwibm9uZVwiJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCInICsgdGhpcy5maWxsICsgJ1wiJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cblxuICAgIHN2ZyArPSAnLz4nO1xuICAgIHJldHVybiBzdmc7XG59O1xuXG5leHBvcnRzLlBhdGggPSBQYXRoO1xuIiwiLy8gVGFibGUgbWV0YWRhdGFcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi90eXBlcycpLmVuY29kZTtcbnZhciBzaXplT2YgPSByZXF1aXJlKCcuL3R5cGVzJykuc2l6ZU9mO1xuXG5mdW5jdGlvbiBUYWJsZSh0YWJsZU5hbWUsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gZmllbGQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbktleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBrID0gb3B0aW9uS2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2ID0gb3B0aW9uc1trXTtcbiAgICAgICAgICAgIGlmICh0aGlzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuVGFibGUucHJvdG90eXBlLnNpemVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuc2l6ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2ICs9IHZhbHVlLnNpemVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW2ZpZWxkLnR5cGVdO1xuICAgICAgICAgICAgY2hlY2suYXNzZXJ0KHR5cGVvZiBzaXplT2ZGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJywgJ0NvdWxkIG5vdCBmaW5kIHNpemVPZiBmdW5jdGlvbiBmb3IgZmllbGQnICsgZmllbGQubmFtZSk7XG4gICAgICAgICAgICB2ICs9IHNpemVPZkZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2O1xufTtcblxuVGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4iLCIvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4uL2VuY29kaW5nJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgSU5ERVggYXJyYXkuXG4vLyBBbiBpbmRleCBhcnJheSBjb25zaXN0cyBvZiBhIGxpc3Qgb2Ygb2Zmc2V0cywgdGhlbiBhIGxpc3Qgb2Ygb2JqZWN0cyBhdCB0aG9zZSBvZmZzZXRzLlxuZnVuY3Rpb24gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG4gICAgLy92YXIgaSwgb2JqZWN0T2Zmc2V0LCBlbmRPZmZzZXQ7XG4gICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIG9iamVjdE9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0O1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG4gICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhkYXRhLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2ldLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kgKyAxXSk7XG4gICAgICAgIGlmIChjb252ZXJzaW9uRm4pIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtvYmplY3RzOiBvYmplY3RzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIHJlYWwgdmFsdWUuXG5mdW5jdGlvbiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBlb2YgPSAxNTtcbiAgICB2YXIgbG9va3VwID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJy4nLCAnRScsICdFLScsIG51bGwsICctJ107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHZhciBuMSA9IGIgPj4gNDtcbiAgICAgICAgdmFyIG4yID0gYiAmIDE1O1xuXG4gICAgICAgIGlmIChuMSA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24xXTtcblxuICAgICAgICBpZiAobjIgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvcGVyYW5kLlxuZnVuY3Rpb24gcGFyc2VPcGVyYW5kKHBhcnNlciwgYjApIHtcbiAgICB2YXIgYjE7XG4gICAgdmFyIGIyO1xuICAgIHZhciBiMztcbiAgICB2YXIgYjQ7XG4gICAgaWYgKGIwID09PSAyOCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiBiMSA8PCA4IHwgYjI7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAyOSkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiNCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIGIxIDw8IDI0IHwgYjIgPDwgMTYgfCBiMyA8PCA4IHwgYjQ7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMzIgJiYgYjAgPD0gMjQ2KSB7XG4gICAgICAgIHJldHVybiBiMCAtIDEzOTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjQ3ICYmIGIwIDw9IDI1MCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG59XG5cbi8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cbi8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG5mdW5jdGlvbiBlbnRyaWVzVG9PYmplY3QoZW50cmllcykge1xuICAgIHZhciBvID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YXIgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgdmFyIG9wZXJhbmRzID0gW107XG4gICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChwYXJzZXIucmVsYXRpdmVPZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG4gICAgICAgIC8vIFZhbHVlcyA8PSAyMSBhcmUgb3BlcmF0b3JzLlxuICAgICAgICBpZiAob3AgPD0gMjEpIHtcbiAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG4gICAgICAgICAgICBpZiAob3AgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW29wLCBvcGVyYW5kc10pO1xuICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBvcGVyYW5kcyAodmFsdWVzKSBjb21lIGJlZm9yZSB0aGUgb3BlcmF0b3JzIChrZXlzKSwgd2Ugc3RvcmUgYWxsIG9wZXJhbmRzIGluIGEgbGlzdFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGBtZXRhYCB3aGljaCBpcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBvcGVyYW5kYCwgYG5hbWVgIGFuZCBgZGVmYXVsdGAuXG5mdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgbmV3RGljdCA9IHt9O1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhbHNvIHdhbnQgdG8gaW5jbHVkZSBtaXNzaW5nIHZhbHVlcywgd2Ugc3RhcnQgb3V0IGZyb20gdGhlIG1ldGEgbGlzdFxuICAgIC8vIGFuZCBsb29rdXAgdmFsdWVzIGluIHRoZSBkaWN0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGRpY3RbbS5vcF07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEaWN0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGhlYWRlci5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWRlciA9IHt9O1xuICAgIGhlYWRlci5mb3JtYXRNYWpvciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkZXIuZm9ybWF0TWlub3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDEpO1xuICAgIGhlYWRlci5zaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICBoZWFkZXIub2Zmc2V0U2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMyk7XG4gICAgaGVhZGVyLnN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG4gICAgaGVhZGVyLmVuZE9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICByZXR1cm4gaGVhZGVyO1xufVxuXG52YXIgVE9QX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnbm90aWNlJywgb3A6IDEsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2NvcHlyaWdodCcsIG9wOiAxMjAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmYW1pbHlOYW1lJywgb3A6IDMsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ3dlaWdodCcsIG9wOiA0LCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgb3A6IDEyMDIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIG9wOiAxMjAzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IC0xMDB9LFxuICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTB9LFxuICAgIHtuYW1lOiAncGFpbnRUeXBlJywgb3A6IDEyMDUsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaGFyc3RyaW5nVHlwZScsIG9wOiAxMjA2LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDJ9LFxuICAgIHtuYW1lOiAnZm9udE1hdHJpeCcsIG9wOiAxMjA3LCB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXX0sXG4gICAge25hbWU6ICd1bmlxdWVJZCcsIG9wOiAxMywgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZm9udEJCb3gnLCBvcDogNSwgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSwgdmFsdWU6IFswLCAwLCAwLCAwXX0sXG4gICAge25hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAneHVpZCcsIG9wOiAxNCwgdHlwZTogW10sIHZhbHVlOiBudWxsfSxcbiAgICB7bmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgb3A6IDE3LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF19XG5dO1xuXG52YXIgUFJJVkFURV9ESUNUX01FVEEgPSBbXG4gICAge25hbWU6ICdzdWJycycsIG9wOiAxOSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2RlZmF1bHRXaWR0aFgnLCBvcDogMjAsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdub21pbmFsV2lkdGhYJywgb3A6IDIxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9XG5dO1xuXG4vLyBQYXJzZSB0aGUgQ0ZGIHRvcCBkaWN0aW9uYXJ5LiBBIENGRiB0YWJsZSBjYW4gY29udGFpbiBtdWx0aXBsZSBmb250cywgZWFjaCB3aXRoIHRoZWlyIG93biB0b3AgZGljdGlvbmFyeS5cbi8vIFRoZSB0b3AgZGljdGlvbmFyeSBjb250YWlucyB0aGUgZXNzZW50aWFsIG1ldGFkYXRhIGZvciB0aGUgZm9udCwgdG9nZXRoZXIgd2l0aCB0aGUgcHJpdmF0ZSBkaWN0aW9uYXJ5LlxuZnVuY3Rpb24gcGFyc2VDRkZUb3BEaWN0KGRhdGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFRPUF9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIHByaXZhdGUgZGljdGlvbmFyeS4gV2UgZG9uJ3QgZnVsbHkgcGFyc2Ugb3V0IGFsbCB0aGUgdmFsdWVzLCBvbmx5IHRoZSBvbmVzIHdlIG5lZWQuXG5mdW5jdGlvbiBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHN0YXJ0LCBzaXplLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2lkO1xuICAgIHZhciBjb3VudDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cbiAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG4gICAgbkdseXBocyAtPSAxO1xuICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gY291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIGVuYyA9IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHZhciBuQ29kZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgY29kZSA9IDE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUmFuZ2VzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICB2YXIgbkxlZnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpcnN0OyBqIDw9IGZpcnN0ICsgbkxlZnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGVuY1tqXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuYywgY2hhcnNldCk7XG59XG5cbi8vIFRha2UgaW4gY2hhcnN0cmluZyBjb2RlIGFuZCByZXR1cm4gYSBHbHlwaCBvYmplY3QuXG4vLyBUaGUgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIHRoZSBUeXBlIDIgQ2hhcnN0cmluZyBGb3JtYXRcbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcnN0cjIuaHRtXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzdHJpbmcoY29kZSwgZm9udCwgaW5kZXgpIHtcbiAgICB2YXIgYzF4O1xuICAgIHZhciBjMXk7XG4gICAgdmFyIGMyeDtcbiAgICB2YXIgYzJ5O1xuICAgIHZhciBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBuU3RlbXMgPSAwO1xuICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICB2YXIgd2lkdGggPSBmb250LmRlZmF1bHRXaWR0aFg7XG4gICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuXG4gICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIG9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIHVuZXZlbiwgdGhhdCBtZWFucyBhIHdpZHRoIGlzIHNwZWNpZmllZC5cbiAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICB9XG5cbiAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUpIHtcbiAgICAgICAgdmFyIGIxO1xuICAgICAgICB2YXIgYjI7XG4gICAgICAgIHZhciBiMztcbiAgICAgICAgdmFyIGI0O1xuICAgICAgICB2YXIgY29kZUluZGV4O1xuICAgICAgICB2YXIgc3VickNvZGU7XG4gICAgICAgIHZhciBqcHg7XG4gICAgICAgIHZhciBqcHk7XG4gICAgICAgIHZhciBjM3g7XG4gICAgICAgIHZhciBjM3k7XG4gICAgICAgIHZhciBjNHg7XG4gICAgICAgIHZhciBjNHk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gaHN0ZW1cbiAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6IC8vIHZzdGVtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiAvLyB2bW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OiAvLyBybGluZXRvXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OiAvLyBobGluZXRvXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OiAvLyB2bGluZXRvXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOiAvLyBjYWxsc3ViclxuICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5zdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LnN1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIHJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgMTI6IC8vIGZsZXggb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGZsZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGR4NiBkeTYgZmQgZmxleCAoMTIgMzUpIHwtXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHk2XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gaGZsZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHg2IGhmbGV4ICgxMiAzNCkgfC1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgYzR5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM2OiAvLyBoZmxleDFcbiAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBmbGV4MVxuICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgMTIwMCArIHYpO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVuZGNoYXJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE4OiAvLyBoc3RlbWhtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOTogLy8gaGludG1hc2tcbiAgICAgICAgICAgIGNhc2UgMjA6IC8vIGNudHJtYXNrXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDIgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMzogLy8gdnN0ZW1obVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ6IC8vIHJjdXJ2ZWxpbmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNjogLy8gdnZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjg6IC8vIHNob3J0aW50XG4gICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikpID4+IDE2KTtcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI5OiAvLyBjYWxsZ3N1YnJcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuZ3N1YnJzQmlhcztcbiAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IGZvbnQuZ3N1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlKHN1YnJDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMTogLy8gaHZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh2IDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBpbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIHYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI0Nykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1MSkge1xuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgodiAtIDI0NykgKiAyNTYgKyBiMSArIDEwOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKC0odiAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICBiNCA9IGNvZGVbaSArIDNdO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlKGNvZGUpO1xuICAgIHZhciBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLnBhdGggPSBwO1xuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBnbHlwaDtcbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlhcztcbn1cblxuLy8gUGFyc2UgdGhlIGBDRkZgIHRhYmxlLCB3aGljaCBjb250YWlucyB0aGUgZ2x5cGggb3V0bGluZXMgaW4gUG9zdFNjcmlwdCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRlRhYmxlKGRhdGEsIHN0YXJ0LCBmb250KSB7XG4gICAgZm9udC50YWJsZXMuY2ZmID0ge307XG4gICAgdmFyIGhlYWRlciA9IHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB2YXIgdG9wRGljdEluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBuYW1lSW5kZXguZW5kT2Zmc2V0KTtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHRvcERpY3RJbmRleC5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHRvcERpY3RJbmRleC5vYmplY3RzWzBdKS5idWZmZXIpO1xuICAgIHZhciB0b3BEaWN0ID0gcGFyc2VDRkZUb3BEaWN0KHRvcERpY3REYXRhLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cbiAgICB2YXIgcHJpdmF0ZURpY3RPZmZzZXQgPSBzdGFydCArIHRvcERpY3RbJ3ByaXZhdGUnXVsxXTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0Wydwcml2YXRlJ11bMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICB2YXIgc3Vick9mZnNldCA9IHByaXZhdGVEaWN0T2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG4gICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQpO1xuICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuc3VicnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VicnMgPSBbXTtcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSAwO1xuICAgIH1cblxuICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuICAgIHZhciBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG5cbiAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhcnNldCwgZm9udC5uR2x5cGhzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMCkgeyAvLyBTdGFuZGFyZCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSBpZiAodG9wRGljdC5lbmNvZGluZyA9PT0gMSkgeyAvLyBFeHBlcnQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBlbmNvZGluZy5DZmZFbmNvZGluZyhlbmNvZGluZy5jZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9XG5cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyU3RyaW5nID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzW2ldO1xuICAgICAgICBmb250LmdseXBocy5wdXNoKHBhcnNlQ0ZGQ2hhcnN0cmluZyhjaGFyU3RyaW5nLCBmb250LCBpKSk7XG4gICAgfVxufVxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHNpZDtcblxuICAgIC8vIElzIHRoZSBzdHJpbmcgaW4gdGhlIENGRiBzdGFuZGFyZCBzdHJpbmdzP1xuICAgIHZhciBpID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cblxuICAgIC8vIElzIHRoZSBzdHJpbmcgYWxyZWFkeSBpbiB0aGUgc3RyaW5nIGluZGV4P1xuICAgIGkgPSBzdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpICsgZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaWQgPSBlbmNvZGluZy5jZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoICsgc3RyaW5ncy5sZW5ndGg7XG4gICAgICAgIHN0cmluZ3MucHVzaChzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2lkO1xufVxuXG5mdW5jdGlvbiBtYWtlSGVhZGVyKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ0hlYWRlcicsIFtcbiAgICAgICAge25hbWU6ICdtYWpvcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdtaW5vcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdoZHJTaXplJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lSW5kZXgoZm9udE5hbWVzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ05hbWUgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnbmFtZXMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5uYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2VudHJ5Lm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWxzKHZhbHVlLCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3RyaW5nKHZhbHVlLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBUaGUgVG9wIERJQ1QgaG91c2VzIHRoZSBnbG9iYWwgZm9udCBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnVG9wIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFRPUF9ESUNUX01FVEEsIGF0dHJzLCBzdHJpbmdzKTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1RvcCBESUNUIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3RvcERpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQudG9wRGljdHMgPSBbe25hbWU6ICd0b3BEaWN0XzAnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdG9wRGljdH1dO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdTdHJpbmcgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5zdHJpbmdzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdTVFJJTkcnLCB2YWx1ZTogc3RyaW5nc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlR2xvYmFsU3VickluZGV4KCkge1xuICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCB1c2Ugc3Vicm91dGluZXMuXG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR2xvYmFsIFN1YnIgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3VicnMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NoYXJzZXRzJywgW1xuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhOYW1lID0gZ2x5cGhOYW1lc1tpXTtcbiAgICAgICAgdmFyIGdseXBoU0lEID0gZW5jb2RlU3RyaW5nKGdseXBoTmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1NJRCcsIHZhbHVlOiBnbHlwaFNJRH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdO1xuICAgIHZhciBwYXRoID0gZ2x5cGgucGF0aDtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIHZhciBkeTtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBDRkYgb25seSBzdXBwb3J0cyBiw6l6aWVyIGN1cnZlcywgc28gY29udmVydCB0aGUgcXVhZCB0byBhIGLDqXppZXIuXG4gICAgICAgICAgICB2YXIgXzEzID0gMSAvIDM7XG4gICAgICAgICAgICB2YXIgXzIzID0gMiAvIDM7XG5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5ldyBjb21tYW5kIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgb3JpZ2luYWwgcGF0aC5cbiAgICAgICAgICAgIGNtZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgICAgICAgICAgeDogY21kLngsXG4gICAgICAgICAgICAgICAgeTogY21kLnksXG4gICAgICAgICAgICAgICAgeDE6IF8xMyAqIHggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTE6IF8xMyAqIHkgKyBfMjMgKiBjbWQueTEsXG4gICAgICAgICAgICAgICAgeDI6IF8xMyAqIGNtZC54ICsgXzIzICogY21kLngxLFxuICAgICAgICAgICAgICAgIHkyOiBfMTMgKiBjbWQueSArIF8yMyAqIGNtZC55MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3Jtb3ZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogMjF9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JsaW5ldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogNX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHZhciBkeDEgPSBNYXRoLnJvdW5kKGNtZC54MSAtIHgpO1xuICAgICAgICAgICAgdmFyIGR5MSA9IE1hdGgucm91bmQoY21kLnkxIC0geSk7XG4gICAgICAgICAgICB2YXIgZHgyID0gTWF0aC5yb3VuZChjbWQueDIgLSBjbWQueDEpO1xuICAgICAgICAgICAgdmFyIGR5MiA9IE1hdGgucm91bmQoY21kLnkyIC0gY21kLnkxKTtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIGNtZC54Mik7XG4gICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSBjbWQueTIpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JyY3VydmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA4fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250b3VycyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkuXG5cbiAgICB9XG5cbiAgICBvcHMucHVzaCh7bmFtZTogJ2VuZGNoYXInLCB0eXBlOiAnT1AnLCB2YWx1ZTogMTR9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdQcml2YXRlIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdEluZGV4KHByaXZhdGVEaWN0KSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1ByaXZhdGUgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdHMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5wcml2YXRlRGljdHMgPSBbe25hbWU6ICdwcml2YXRlRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHByaXZhdGVEaWN0fV07XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ0ZGICcsIFtcbiAgICAgICAge25hbWU6ICdoZWFkZXInLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICduYW1lSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICd0b3BEaWN0SW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2dsb2JhbFN1YnJJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJzZXRzJywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3NJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ3ByaXZhdGVEaWN0SW5kZXgnLCB0eXBlOiAnVEFCTEUnfVxuICAgIF0pO1xuXG4gICAgdmFyIGZvbnRTY2FsZSA9IDEgLyBvcHRpb25zLnVuaXRzUGVyRW07XG4gICAgLy8gV2UgdXNlIG5vbi16ZXJvIHZhbHVlcyBmb3IgdGhlIG9mZnNldHMgc28gdGhhdCB0aGUgRElDVCBlbmNvZGVzIHRoZW0uXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgVG9wIERJQ1QgcGxheXMgYSByb2xlIGluIG9mZnNldCBjYWxjdWxhdGlvbixcbiAgICAvLyBhbmQgdGhlIHNpemUgc2hvdWxkbid0IGNoYW5nZSBhZnRlciB3ZSd2ZSB3cml0dGVuIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgZnVsbE5hbWU6IG9wdGlvbnMuZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG4gICAgICAgIGZvbnRNYXRyaXg6IFtmb250U2NhbGUsIDAsIDAsIGZvbnRTY2FsZSwgMCwgMF0sXG4gICAgICAgIGNoYXJzZXQ6IDk5OSxcbiAgICAgICAgZW5jb2Rpbmc6IDAsXG4gICAgICAgIGNoYXJTdHJpbmdzOiA5OTksXG4gICAgICAgIHByaXZhdGU6IFswLCA5OTldXG4gICAgfTtcblxuICAgIHZhciBwcml2YXRlQXR0cnMgPSB7fTtcblxuICAgIHZhciBnbHlwaE5hbWVzID0gW107XG5cbiAgICAvLyBTa2lwIGZpcnN0IGdseXBoICgubm90ZGVmKVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoTmFtZXMucHVzaChnbHlwaHNbaV0ubmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZ3MgPSBbXTtcblxuICAgIHQuaGVhZGVyID0gbWFrZUhlYWRlcigpO1xuICAgIHQubmFtZUluZGV4ID0gbWFrZU5hbWVJbmRleChbb3B0aW9ucy5wb3N0U2NyaXB0TmFtZV0pO1xuICAgIHZhciB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuICAgIHQudG9wRGljdEluZGV4ID0gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KTtcbiAgICB0Lmdsb2JhbFN1YnJJbmRleCA9IG1ha2VHbG9iYWxTdWJySW5kZXgoKTtcbiAgICB0LmNoYXJzZXRzID0gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpO1xuICAgIHQuY2hhclN0cmluZ3NJbmRleCA9IG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocyk7XG4gICAgdmFyIHByaXZhdGVEaWN0ID0gbWFrZVByaXZhdGVEaWN0KHByaXZhdGVBdHRycywgc3RyaW5ncyk7XG4gICAgdC5wcml2YXRlRGljdEluZGV4ID0gbWFrZVByaXZhdGVEaWN0SW5kZXgocHJpdmF0ZURpY3QpO1xuXG4gICAgLy8gTmVlZHMgdG8gY29tZSBhdCB0aGUgZW5kLCB0byBlbmNvZGUgYWxsIGN1c3RvbSBzdHJpbmdzIHVzZWQgaW4gdGhlIGZvbnQuXG4gICAgdC5zdHJpbmdJbmRleCA9IG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKTtcblxuICAgIHZhciBzdGFydE9mZnNldCA9IHQuaGVhZGVyLnNpemVPZigpICtcbiAgICAgICAgdC5uYW1lSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnRvcERpY3RJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuc3RyaW5nSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0Lmdsb2JhbFN1YnJJbmRleC5zaXplT2YoKTtcbiAgICBhdHRycy5jaGFyc2V0ID0gc3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBXZSB1c2UgdGhlIENGRiBzdGFuZGFyZCBlbmNvZGluZzsgcHJvcGVyIGVuY29kaW5nIHdpbGwgYmUgaGFuZGxlZCBpbiBjbWFwLlxuICAgIGF0dHJzLmVuY29kaW5nID0gMDtcbiAgICBhdHRycy5jaGFyU3RyaW5ncyA9IGF0dHJzLmNoYXJzZXQgKyB0LmNoYXJzZXRzLnNpemVPZigpO1xuICAgIGF0dHJzLnByaXZhdGVbMV0gPSBhdHRycy5jaGFyU3RyaW5ncyArIHQuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKTtcblxuICAgIC8vIFJlY3JlYXRlIHRoZSBUb3AgRElDVCBJTkRFWCB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuXG4gICAgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlQ0ZGVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ0ZGVGFibGU7XG4iLCIvLyBUaGUgYGNtYXBgIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY21hcC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBgY21hcGAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgY21hcCA9IHt9O1xuICAgIGNtYXAudmVyc2lvbiA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCk7XG4gICAgY2hlY2suYXJndW1lbnQoY21hcC52ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjbWFwLm51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybUlkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkpO1xuICAgICAgICB2YXIgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgMik7XG4gICAgICAgIGlmIChwbGF0Zm9ybUlkID09PSAzICYmIChlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDApKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LCBzbyByZXR1cm4gbnVsbC5cbiAgICAgICAgLy8gVGhpcyBmb250IHdpbGwgYmUgbWFya2VkIGFzIHVuc3VwcG9ydGVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuICAgIGNtYXAuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGNtYXAuZm9ybWF0ID09PSA0LCAnT25seSBmb3JtYXQgNCBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkLicpO1xuXG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBzZWdDb3VudCBpcyBzdG9yZWQgeCAyLlxuICAgIHZhciBzZWdDb3VudDtcbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcblxuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG4gICAgdmFyIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICB2YXIgc3RhcnRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMik7XG4gICAgdmFyIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDQpO1xuICAgIHZhciBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2KTtcbiAgICB2YXIgZ2x5cGhJbmRleE9mZnNldCA9IHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDg7XG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4O1xuICAgICAgICB2YXIgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3RhcnRDb3VudCA9IHN0YXJ0Q291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkRGVsdGEgPSBpZERlbHRhUGFyc2VyLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgdmFyIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENvdW50OyBjIDw9IGVuZENvdW50OyBjICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpZFJhbmdlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlkUmFuZ2VPZmZzZXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgY3VycmVudCBvZmZzZXQgaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCA9IChpZFJhbmdlT2Zmc2V0UGFyc2VyLm9mZnNldCArIGlkUmFuZ2VPZmZzZXRQYXJzZXIucmVsYXRpdmVPZmZzZXQgLSAyKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2VnbWVudCwgbXVsdGlwbGllZCBieSAyIGZvciBVU0hPUlRzLlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhGRkZGO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBnbHlwaEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIHZhciBpO1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdjbWFwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDEyfSxcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlZ0NvdW50WDInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuXG4gICAgdC5zZWdtZW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRTZWdtZW50KHQsIGdseXBoLnVuaWNvZGVzW2pdLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuc2VnbWVudHMgPSB0LnNlZ21lbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KTtcblxuICAgIHZhciBzZWdDb3VudDtcbiAgICBzZWdDb3VudCA9IHQuc2VnbWVudHMubGVuZ3RoO1xuICAgIHQuc2VnQ291bnRYMiA9IHNlZ0NvdW50ICogMjtcbiAgICB0LnNlYXJjaFJhbmdlID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhzZWdDb3VudCkgLyBNYXRoLmxvZygyKSkpICogMjtcbiAgICB0LmVudHJ5U2VsZWN0b3IgPSBNYXRoLmxvZyh0LnNlYXJjaFJhbmdlIC8gMikgLyBNYXRoLmxvZygyKTtcbiAgICB0LnJhbmdlU2hpZnQgPSB0LnNlZ0NvdW50WDIgLSB0LnNlYXJjaFJhbmdlO1xuXG4gICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXTtcbiAgICB2YXIgc3RhcnRDb3VudHMgPSBbXTtcbiAgICB2YXIgaWREZWx0YXMgPSBbXTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldHMgPSBbXTtcbiAgICB2YXIgZ2x5cGhJZHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcbiAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZW5kQ291bnRzKTtcbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVzZXJ2ZWRQYWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9KTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChzdGFydENvdW50cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWREZWx0YXMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkUmFuZ2VPZmZzZXRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChnbHlwaElkcyk7XG5cbiAgICB0Lmxlbmd0aCA9IDE0ICsgLy8gU3VidGFibGUgaGVhZGVyXG4gICAgICAgIGVuZENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgMiArIC8vIHJlc2VydmVkUGFkXG4gICAgICAgIHN0YXJ0Q291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZERlbHRhcy5sZW5ndGggKiAyICtcbiAgICAgICAgaWRSYW5nZU9mZnNldHMubGVuZ3RoICogMiArXG4gICAgICAgIGdseXBoSWRzLmxlbmd0aCAqIDI7XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlQ21hcFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUNtYXBUYWJsZTtcbiIsIi8vIFRoZSBgZ2x5ZmAgdGFibGUgZGVzY3JpYmVzIHRoZSBnbHlwaHMgaW4gVHJ1ZVR5cGUgb3V0bGluZSBmb3JtYXQuXG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZ2x5Zi5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIF9nbHlwaCA9IHJlcXVpcmUoJy4uL2dseXBoJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi9wYXRoJyk7XG5cbi8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGRhdGEgZm9yIGEgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBwcmV2aW91c1ZhbHVlLCBzaG9ydFZlY3RvckJpdE1hc2ssIHNhbWVCaXRNYXNrKSB7XG4gICAgdmFyIHY7XG4gICAgaWYgKChmbGFnICYgc2hvcnRWZWN0b3JCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGUgaXMgMSBieXRlIGxvbmcuXG4gICAgICAgIHYgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAvLyBUaGUgYHNhbWVgIGJpdCBpcyByZS11c2VkIGZvciBzaG9ydCB2YWx1ZXMgdG8gc2lnbmlmeSB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA9PT0gMCkge1xuICAgICAgICAgICAgdiA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2O1xufVxuXG4vLyBQYXJzZSBhIFRydWVUeXBlIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaChkYXRhLCBzdGFydCwgaW5kZXgsIGZvbnQpIHtcbiAgICAvL3ZhciBwLCBnbHlwaCwgZmxhZywgaSwgaiwgZmxhZ3MsXG4gICAgLy8gICAgZW5kUG9pbnRJbmRpY2VzLCBudW1iZXJPZkNvb3JkaW5hdGVzLCByZXBlYXRDb3VudCwgcG9pbnRzLCBwb2ludCwgcHgsIHB5LFxuICAgIC8vICAgIGNvbXBvbmVudCwgbW9yZUNvbXBvbmVudHM7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZ2x5cGggPSBuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaW5kZXh9KTtcbiAgICBnbHlwaC5udW1iZXJPZkNvbnRvdXJzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC54TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHZhciBmbGFncztcbiAgICB2YXIgZmxhZztcbiAgICBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA+IDApIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICB2YXIgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaC5udW1iZXJPZkNvbnRvdXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1iZXJPZkNvb3JkaW5hdGVzID0gZW5kUG9pbnRJbmRpY2VzW2VuZFBvaW50SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIGZsYWdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZsYWcgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICBpZiAoKGZsYWcgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5vbkN1cnZlID0gISEoZmxhZyAmIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5sYXN0UG9pbnRPZkNvbnRvdXIgPSBlbmRQb2ludEluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweSwgNCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHdoaWxlIChtb3JlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgc2NhbGUwMTogMCxcbiAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSB3b3Jkc1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBieXRlc1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmbGFncyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgNjQpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gWCAvIFkgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgMTI4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgMngyIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMDEgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTEwID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBtb3JlQ29tcG9uZW50cyA9ICEhKGZsYWdzICYgMzIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXRoLlBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBnZXRDb250b3Vycyhwb2ludHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNvbnRvdXIgPSBjb250b3Vyc1tpXTtcbiAgICAgICAgdmFyIGZpcnN0UHQgPSBjb250b3VyWzBdO1xuICAgICAgICB2YXIgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgY3VydmVQdDtcbiAgICAgICAgdmFyIHJlYWxGaXJzdFBvaW50O1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnZlUHQgPSBmaXJzdFB0O1xuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBvaW50IGlzIHN5bnRoZXNpemVkLCBzbyBkb24ndCBza2lwIHRoZSByZWFsIGZpcnN0IHBvaW50LlxuICAgICAgICAgICAgcmVhbEZpcnN0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAubW92ZVRvKGZpcnN0UHQueCwgZmlyc3RQdC55KTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcmVhbEZpcnN0UG9pbnQgPyAxIDogMDsgaiA8IGNvbnRvdXIubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICB2YXIgcHJldlB0ID0gaiA9PT0gMCA/IGZpcnN0UHQgOiBjb250b3VyW2ogLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2UHQub25DdXJ2ZSAmJiBwdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgICAgICAgICAgcC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZQdC5vbkN1cnZlICYmICFwdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgY3VydmVQdCA9IHB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkUHQgPSB7IHg6IChwcmV2UHQueCArIHB0LngpIC8gMiwgeTogKHByZXZQdC55ICsgcHQueSkgLyAyIH07XG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHByZXZQdC54LCBwcmV2UHQueSwgbWlkUHQueCwgbWlkUHQueSk7XG4gICAgICAgICAgICAgICAgY3VydmVQdCA9IHB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldlB0Lm9uQ3VydmUgJiYgcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIHBvaW50IG9mZi1jdXJ2ZSwgdGhpcyBwb2ludCBvbi1jdXJ2ZS5cbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIHB0LngsIHB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RQdCAhPT0gbGFzdFB0KSB7XG4gICAgICAgICAgICAvLyBDb25uZWN0IHRoZSBsYXN0IGFuZCBmaXJzdCBwb2ludHNcbiAgICAgICAgICAgIGlmIChjdXJ2ZVB0KSB7XG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAubGluZVRvKGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG4gICAgZm9yIChpID0gMDsgaSA8IGxvY2EubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBsb2NhW2ldO1xuICAgICAgICB2YXIgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChwYXJzZUdseXBoKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBpLCBmb250KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaX0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHbyBvdmVyIHRoZSBnbHlwaHMgYWdhaW4sIHJlc29sdmluZyB0aGUgY29tcG9zaXRlIGdseXBocy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLmNvbXBvbmVudHMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHNbY29tcG9uZW50LmdseXBoSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRHbHlwaC5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gZ2x5cGgucG9pbnRzLmNvbmNhdCh0cmFuc2Zvcm1lZFBvaW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGgucGF0aCA9IGdldFBhdGgoZ2x5cGgucG9pbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHbHlmVGFibGU7XG4iLCIvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gRm9ybWF0IDEgaXMgYSBzaW1wbGUgbGlzdCBvZiBnbHlwaCBpZHMsXG4vLyBGb3JtYXQgMiBpcyBhIGxpc3Qgb2YgcmFuZ2VzLiBJdCBpcyBleHBhbmRlZCBpbiBhIGxpc3Qgb2YgZ2x5cGhzLCBtYXliZSBub3QgdGhlIGJlc3QgaWRlYS5cbmZ1bmN0aW9uIHBhcnNlQ292ZXJhZ2VUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSAgcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHAucGFyc2VVU2hvcnRMaXN0KGNvdW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciBjb3ZlcmFnZSA9IFtdO1xuICAgICAgICBmb3IgKDsgY291bnQtLTspIHtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3ZlcmFnZVtpbmRleCsrXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY292ZXJhZ2U7XG4gICAgfVxufVxuXG4vLyBQYXJzZSBhIENsYXNzIERlZmluaXRpb24gVGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBnZXRzIGEgY2xhc3MgdmFsdWUgZnJvbSBhIGdseXBoIElELlxuZnVuY3Rpb24gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gRm9ybWF0IDEgc3BlY2lmaWVzIGEgcmFuZ2Ugb2YgY29uc2VjdXRpdmUgZ2x5cGggaW5kaWNlcywgb25lIGNsYXNzIHBlciBnbHlwaCBJRC5cbiAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBnbHlwaENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3NlcyA9IHAucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZ2x5cGhJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXNbZ2x5cGhJRCAtIHN0YXJ0R2x5cGhdIHx8IDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICAvLyBGb3JtYXQgMiBkZWZpbmVzIG11bHRpcGxlIGdyb3VwcyBvZiBnbHlwaCBpbmRpY2VzIHRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIGNsYXNzLlxuICAgICAgICB2YXIgcmFuZ2VDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN0YXJ0R2x5cGhzID0gW107XG4gICAgICAgIHZhciBlbmRHbHlwaHMgPSBbXTtcbiAgICAgICAgdmFyIGNsYXNzVmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzdGFydEdseXBoc1tpXSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGVuZEdseXBoc1tpXSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGNsYXNzVmFsdWVzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgIHZhciByID0gc3RhcnRHbHlwaHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBjID0gKGwgKyByICsgMSkgPj4gMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJRCA8IHN0YXJ0R2x5cGhzW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBjIC0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFydEdseXBoc1tsXSA8PSBnbHlwaElEICYmIGdseXBoSUQgPD0gZW5kR2x5cGhzW2xdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsdWVzW2xdIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBwYWlyIGFkanVzdG1lbnQgcG9zaXRpb25pbmcgc3VidGFibGUsIGZvcm1hdCAxIG9yIGZvcm1hdCAyXG4vLyBUaGUgc3VidGFibGUgaXMgcmV0dXJuZWQgaW4gdGhlIGZvcm0gb2YgYSBsb29rdXAgZnVuY3Rpb24uXG5mdW5jdGlvbiBwYXJzZVBhaXJQb3NTdWJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgdmFyIGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY292ZXJhZ2VPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0ICsgY292ZXJhZ2VPZmZzZXQpO1xuICAgIC8vIHZhbHVlRm9ybWF0IDQ6IFhBZHZhbmNlIG9ubHksIDE6IFhQbGFjZW1lbnQgb25seSwgMDogbm8gVmFsdWVSZWNvcmQgZm9yIHNlY29uZCBnbHlwaFxuICAgIC8vIE9ubHkgdmFsdWVGb3JtYXQxPTQgYW5kIHZhbHVlRm9ybWF0Mj0wIGlzIHN1cHBvcnRlZC5cbiAgICB2YXIgdmFsdWVGb3JtYXQxID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlMTtcbiAgICB2YXIgdmFsdWUyO1xuICAgIGlmICh2YWx1ZUZvcm1hdDEgIT09IDQgfHwgdmFsdWVGb3JtYXQyICE9PSAwKSByZXR1cm47XG4gICAgdmFyIHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIHZhciBwYWlyU2V0Q291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBwYWlyU2V0ID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIG9mZnNldHMgdG8gUGFpclNldCB0YWJsZXMtZnJvbSBiZWdpbm5pbmcgb2YgUGFpclBvcyBzdWJ0YWJsZS1vcmRlcmVkIGJ5IENvdmVyYWdlIEluZGV4XG4gICAgICAgIHZhciBwYWlyU2V0T2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3QocGFpclNldENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgZmlyc3RHbHlwaCA9IDA7IGZpcnN0R2x5cGggPCBwYWlyU2V0Q291bnQ7IGZpcnN0R2x5cGgrKykge1xuICAgICAgICAgICAgdmFyIHBhaXJTZXRPZmZzZXQgPSBwYWlyU2V0T2Zmc2V0c1tmaXJzdEdseXBoXTtcbiAgICAgICAgICAgIHZhciBzaGFyZWRQYWlyU2V0ID0gc2hhcmVkUGFpclNldHNbcGFpclNldE9mZnNldF07XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFBhaXJTZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHBhaXJzZXQgdGFibGUgaW4gYSBwYWlyIGFkanVzdG1lbnQgc3VidGFibGUgZm9ybWF0IDFcbiAgICAgICAgICAgICAgICBzaGFyZWRQYWlyU2V0ID0ge307XG4gICAgICAgICAgICAgICAgcC5yZWxhdGl2ZU9mZnNldCA9IHBhaXJTZXRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhaXJWYWx1ZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBwYWlyVmFsdWVDb3VudC0tOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kR2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDEpIHZhbHVlMSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHZhbHVlMSBpcyB0aGUgWEFkdmFuY2UgYW5kIHZhbHVlMiBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGFpclNldFtzZWNvbmRHbHlwaF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYWlyU2V0W2NvdmVyYWdlW2ZpcnN0R2x5cGhdXSA9IHNoYXJlZFBhaXJTZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgICAgICAgICB2YXIgcGFpcnMgPSBwYWlyU2V0W2xlZnRHbHlwaF07XG4gICAgICAgICAgICBpZiAocGFpcnMpIHJldHVybiBwYWlyc1tyaWdodEdseXBoXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIFBhaXIgUG9zaXRpb25pbmcgQWRqdXN0bWVudDogRm9ybWF0IDJcbiAgICAgICAgdmFyIGNsYXNzRGVmMU9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQgKyBjbGFzc0RlZjFPZmZzZXQpO1xuICAgICAgICB2YXIgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0ICsgY2xhc3NEZWYyT2Zmc2V0KTtcblxuICAgICAgICAvLyBQYXJzZSBrZXJuaW5nIHZhbHVlcyBieSBjbGFzcyBwYWlyLlxuICAgICAgICB2YXIga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzMUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtpXSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIHZhciBjb3ZlcmVkID0ge307XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3ZlcmFnZS5sZW5ndGg7IGkrKykgY292ZXJlZFtjb3ZlcmFnZVtpXV0gPSAxO1xuXG4gICAgICAgIC8vIEdldCB0aGUga2VybmluZyB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBnbHlwaCBwYWlyLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgICAgICAgICBpZiAoIWNvdmVyZWRbbGVmdEdseXBoXSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpO1xuICAgICAgICAgICAgdmFyIGNsYXNzMiA9IGdldENsYXNzMihyaWdodEdseXBoKTtcbiAgICAgICAgICAgIHZhciBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtjbGFzczFdO1xuXG4gICAgICAgICAgICBpZiAoa2VybmluZ1Jvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXJuaW5nUm93W2NsYXNzMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBQYXJzZSBhIExvb2t1cFRhYmxlIChwcmVzZW50IGluIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzKS5cbmZ1bmN0aW9uIHBhcnNlTG9va3VwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBsb29rdXBUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBsb29rdXBGbGFnID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgdmFyIHN1YlRhYmxlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN1YlRhYmxlT2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3Qoc3ViVGFibGVDb3VudCk7XG4gICAgdmFyIHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YlRhYmxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgc3VidGFibGVzLnB1c2gocGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQgKyBzdWJUYWJsZU9mZnNldHNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBmaW5kcyB0aGUga2VybmluZyB2YWx1ZXMgaW4gdGhlIHN1YnRhYmxlcy5cbiAgICAgICAgdGFibGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3VidGFibGVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN1YnRhYmxlc1tpXShsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gUGFyc2UgdGhlIGBHUE9TYCB0YWJsZSB3aGljaCBjb250YWlucywgYW1vbmcgb3RoZXIgdGhpbmdzLCBrZXJuaW5nIHBhaXJzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24uJyk7XG5cbiAgICAvLyBTY3JpcHRMaXN0IGFuZCBGZWF0dXJlTGlzdCAtIGlnbm9yZWQgZm9yIG5vd1xuICAgIHBhcnNlVGFnZ2VkTGlzdFRhYmxlKGRhdGEsIHN0YXJ0ICsgcC5wYXJzZVVTaG9ydCgpKTtcbiAgICAvLyAna2VybicgaXMgdGhlIGZlYXR1cmUgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHBhcnNlVGFnZ2VkTGlzdFRhYmxlKGRhdGEsIHN0YXJ0ICsgcC5wYXJzZVVTaG9ydCgpKTtcblxuICAgIC8vIExvb2t1cExpc3RcbiAgICB2YXIgbG9va3VwTGlzdE9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gbG9va3VwTGlzdE9mZnNldDtcbiAgICB2YXIgbG9va3VwQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGxvb2t1cFRhYmxlT2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3QobG9va3VwQ291bnQpO1xuICAgIHZhciBsb29rdXBMaXN0QWJzb2x1dGVPZmZzZXQgPSBzdGFydCArIGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29rdXBDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IHBhcnNlTG9va3VwVGFibGUoZGF0YSwgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ICsgbG9va3VwVGFibGVPZmZzZXRzW2ldKTtcbiAgICAgICAgaWYgKHRhYmxlLmxvb2t1cFR5cGUgPT09IDIgJiYgIWZvbnQuZ2V0R3Bvc0tlcm5pbmdWYWx1ZSkgZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlID0gdGFibGUuZ2V0S2VybmluZ1ZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlR3Bvc1RhYmxlO1xuIiwiLy8gVGhlIGBoZWFkYCB0YWJsZSBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2hlYWQuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIZWFkVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGVhZC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoZWFkLmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQocC5wYXJzZUZpeGVkKCkgKiAxMDAwKSAvIDEwMDA7XG4gICAgaGVhZC5jaGVja1N1bUFkanVzdG1lbnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBoZWFkLm1hZ2ljTnVtYmVyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQoaGVhZC5tYWdpY051bWJlciA9PT0gMHg1RjBGM0NGNSwgJ0ZvbnQgaGVhZGVyIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIuJyk7XG4gICAgaGVhZC5mbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLnVuaXRzUGVyRW0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5jcmVhdGVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQubW9kaWZpZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC54TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5tYWNTdHlsZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmxvd2VzdFJlY1BQRU0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5mb250RGlyZWN0aW9uSGludCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQuaW5kZXhUb0xvY0Zvcm1hdCA9IHAucGFyc2VTaG9ydCgpOyAgICAgLy8gNTBcbiAgICBoZWFkLmdseXBoRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHJldHVybiBoZWFkO1xufVxuXG5mdW5jdGlvbiBtYWtlSGVhZFRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoZWFkJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udFJldmlzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtQWRqdXN0bWVudCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWdpY051bWJlcicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDVGMEYzQ0Y1fSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5pdHNQZXJFbScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMTAwMH0sXG4gICAgICAgIHtuYW1lOiAnY3JlYXRlZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbW9kaWZpZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWFjU3R5bGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xvd2VzdFJlY1BQRU0nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZvbnREaXJlY3Rpb25IaW50JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICB7bmFtZTogJ2luZGV4VG9Mb2NGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZ2x5cGhEYXRhRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9XG4gICAgXSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUhlYWRUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VIZWFkVGFibGU7XG4iLCIvLyBUaGUgYGhoZWFgIHRhYmxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGZvciBob3Jpem9udGFsIGxheW91dC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGhlYS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIGhvcml6b250YWwgaGVhZGVyIGBoaGVhYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIaGVhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGhlYSA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaGhlYS52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBoaGVhLmFzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5kZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmxpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmFkdmFuY2VXaWR0aE1heCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoaGVhLm1pbkxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubWluUmlnaHRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEueE1heEV4dGVudCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJpc2UgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSdW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0T2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIGhoZWEubWV0cmljRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubnVtYmVyT2ZITWV0cmljcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICByZXR1cm4gaGhlYTtcbn1cblxuZnVuY3Rpb24gbWFrZUhoZWFUYWJsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGhlYScsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2FzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2Rlc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsaW5lR2FwJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FkdmFuY2VXaWR0aE1heCcsIHR5cGU6ICdVRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTGVmdFNpZGVCZWFyaW5nJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pblJpZ2h0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heEV4dGVudCcsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUmlzZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUnVuJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0T2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkNCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtZXRyaWNEYXRhRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bWJlck9mSE1ldHJpY3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUhoZWFUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VIaGVhVGFibGU7XG4iLCIvLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2htdHguaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gYWR2YW5jZVdpZHRoO1xuICAgICAgICBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgPSBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSG10eFRhYmxlKGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdobXR4JywgW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgdmFyIGFkdmFuY2VXaWR0aCA9IGdseXBoLmFkdmFuY2VXaWR0aCB8fCAwO1xuICAgICAgICB2YXIgbGVmdFNpZGVCZWFyaW5nID0gZ2x5cGgubGVmdFNpZGVCZWFyaW5nIHx8IDA7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdhZHZhbmNlV2lkdGhfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogYWR2YW5jZVdpZHRofSk7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdsZWZ0U2lkZUJlYXJpbmdfJyArIGksIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiBsZWZ0U2lkZUJlYXJpbmd9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSG10eFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhtdHhUYWJsZTtcbiIsIi8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cbi8vIE5vdGUgdGhhdCBzb21lIGZvbnRzIHVzZSB0aGUgR1BPUyBPcGVuVHlwZSBsYXlvdXQgdGFibGUgdG8gc3BlY2lmeSBrZXJuaW5nLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9rZXJuLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xuXG4vLyBQYXJzZSB0aGUgYGtlcm5gIHRhYmxlIHdoaWNoIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZUtlcm5UYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBuVGFibGVzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgdmFyIHN1YlRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJUYWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHN1Yi10YWJsZSB2ZXJzaW9uLicpO1xuICAgIC8vIFNraXAgc3ViVGFibGVMZW5ndGgsIHN1YlRhYmxlQ292ZXJhZ2VcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDIpO1xuICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYWlycztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlS2VyblRhYmxlO1xuIiwiLy8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9sb2NhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG5cbi8vIFBhcnNlIHRoZSBgbG9jYWAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udCxcbi8vIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdseXBoRGF0YSB0YWJsZS5cbi8vIFRoZSBudW1iZXIgb2YgZ2x5cGhzIHN0b3JlZCBpbiB0aGUgYGxvY2FgIHRhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgYG1heHBgIHRhYmxlICh1bmRlciBudW1HbHlwaHMpXG4vLyBUaGUgbG9jYSB0YWJsZSBoYXMgdHdvIHZlcnNpb25zOiBhIHNob3J0IHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVTaG9ydHMsIGFuZCBhIGxvbmdcbi8vIHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVMb25ncy4gVGhlIGBoZWFkYCB0YWJsZSBzcGVjaWZpZXMgd2hpY2ggdmVyc2lvbiB0byB1c2Vcbi8vICh1bmRlciBpbmRleFRvTG9jRm9ybWF0KS5cbmZ1bmN0aW9uIHBhcnNlTG9jYVRhYmxlKGRhdGEsIHN0YXJ0LCBudW1HbHlwaHMsIHNob3J0VmVyc2lvbikge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bUdseXBocyArIDEuXG4gICAgdmFyIGdseXBoT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE9mZnNldCA9IHBhcnNlRm4uY2FsbChwKTtcbiAgICAgICAgaWYgKHNob3J0VmVyc2lvbikge1xuICAgICAgICAgICAgLy8gVGhlIHNob3J0IHRhYmxlIHZlcnNpb24gc3RvcmVzIHRoZSBhY3R1YWwgb2Zmc2V0IGRpdmlkZWQgYnkgMi5cbiAgICAgICAgICAgIGdseXBoT2Zmc2V0ICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoT2Zmc2V0cztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlTG9jYVRhYmxlO1xuIiwiLy8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG4vLyBXZSBuZWVkIGl0IGp1c3QgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZ2x5cGhzIGluIHRoZSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9tYXhwLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgbWF4aW11bSBwcm9maWxlIGBtYXhwYCB0YWJsZS5cbmZ1bmN0aW9uIHBhcnNlTWF4cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG1heHAgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG1heHAudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgbWF4cC5udW1HbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG1heHAudmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIG1heHAubWF4UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZVBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhab25lcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhUd2lsaWdodFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdG9yYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEZ1bmN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhJbnN0cnVjdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RhY2tFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTaXplT2ZJbnN0cnVjdGlvbnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RGVwdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heHA7XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXhwVGFibGUobnVtR2x5cGhzKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbWF4cCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMDUwMDB9LFxuICAgICAgICB7bmFtZTogJ251bUdseXBocycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbnVtR2x5cGhzfVxuICAgIF0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VNYXhwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTWF4cFRhYmxlO1xuIiwiLy8gVGhlIGBuYW1lYCBuYW1pbmcgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL25hbWUuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kZSA9IHJlcXVpcmUoJy4uL3R5cGVzJykuZW5jb2RlO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIE5hbWVJRHMgZm9yIHRoZSBuYW1lIHRhYmxlLlxudmFyIG5hbWVUYWJsZU5hbWVzID0gW1xuICAgICdjb3B5cmlnaHQnLCAgICAgICAgICAgICAgLy8gMFxuICAgICdmb250RmFtaWx5JywgICAgICAgICAgICAgLy8gMVxuICAgICdmb250U3ViZmFtaWx5JywgICAgICAgICAgLy8gMlxuICAgICd1bmlxdWVJRCcsICAgICAgICAgICAgICAgLy8gM1xuICAgICdmdWxsTmFtZScsICAgICAgICAgICAgICAgLy8gNFxuICAgICd2ZXJzaW9uJywgICAgICAgICAgICAgICAgLy8gNVxuICAgICdwb3N0U2NyaXB0TmFtZScsICAgICAgICAgLy8gNlxuICAgICd0cmFkZW1hcmsnLCAgICAgICAgICAgICAgLy8gN1xuICAgICdtYW51ZmFjdHVyZXInLCAgICAgICAgICAgLy8gOFxuICAgICdkZXNpZ25lcicsICAgICAgICAgICAgICAgLy8gOVxuICAgICdkZXNjcmlwdGlvbicsICAgICAgICAgICAgLy8gMTBcbiAgICAnbWFudWZhY3R1cmVyVVJMJywgICAgICAgIC8vIDExXG4gICAgJ2Rlc2lnbmVyVVJMJywgICAgICAgICAgICAvLyAxMlxuICAgICdsaWNlbmNlJywgICAgICAgICAgICAgICAgLy8gMTNcbiAgICAnbGljZW5jZVVSTCcsICAgICAgICAgICAgIC8vIDE0XG4gICAgJ3Jlc2VydmVkJywgICAgICAgICAgICAgICAvLyAxNVxuICAgICdwcmVmZXJyZWRGYW1pbHknLCAgICAgICAgLy8gMTZcbiAgICAncHJlZmVycmVkU3ViZmFtaWx5JywgICAgIC8vIDE3XG4gICAgJ2NvbXBhdGlibGVGdWxsTmFtZScsICAgICAvLyAxOFxuICAgICdzYW1wbGVUZXh0JywgICAgICAgICAgICAgLy8gMTlcbiAgICAncG9zdFNjcmlwdEZpbmRGb250TmFtZScsIC8vIDIwXG4gICAgJ3d3c0ZhbWlseScsICAgICAgICAgICAgICAvLyAyMVxuICAgICd3d3NTdWJmYW1pbHknICAgICAgICAgICAgLy8gMjJcbl07XG5cbi8vIFBhcnNlIHRoZSBuYW1pbmcgYG5hbWVgIHRhYmxlXG4vLyBPbmx5IFdpbmRvd3MgVW5pY29kZSBFbmdsaXNoIG5hbWVzIGFyZSBzdXBwb3J0ZWQuXG4vLyBGb3JtYXQgMSBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gcGFyc2VOYW1lVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgbmFtZSA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgbmFtZS5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdHJpbmdPZmZzZXQgPSBwLm9mZnNldCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdW5rbm93bkNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2VJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gbmFtZVRhYmxlTmFtZXNbbmFtZUlEXTtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIHBsYXRmb3JtSUQgLSBlbmNvZGluZ0lEIC0gbGFuZ3VhZ2VJRCBzdGFuZGFyZCBjb21iaW5hdGlvbnMgOlxuICAgICAgICAvLyAxIC0gMCAtIDAgOiBNYWNpbnRvc2gsIFJvbWFuLCBFbmdsaXNoXG4gICAgICAgIC8vIDMgLSAxIC0gMHg0MDkgOiBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBlbi1VU1xuICAgICAgICBpZiAocGxhdGZvcm1JRCA9PT0gMyAmJiBlbmNvZGluZ0lEID09PSAxICYmIGxhbmd1YWdlSUQgPT09IDB4NDA5KSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyAyO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnRzW2pdID0gcGFyc2UuZ2V0U2hvcnQoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBuYW1lW3Byb3BlcnR5XSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVua25vd25Db3VudCsrO1xuICAgICAgICAgICAgICAgIG5hbWVbJ3Vua25vd24nICsgdW5rbm93bkNvdW50XSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKG5hbWUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIG5hbWUubGFuZ1RhZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVJlY29yZChwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnTmFtZVJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICdwbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBwbGF0Zm9ybUlEfSxcbiAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBlbmNvZGluZ0lEfSxcbiAgICAgICAge25hbWU6ICdsYW5ndWFnZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5ndWFnZUlEfSxcbiAgICAgICAge25hbWU6ICduYW1lSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVJRH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogb2Zmc2V0fVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBhZGRNYWNpbnRvc2hOYW1lUmVjb3JkKHQsIHJlY29yZElELCBzLCBvZmZzZXQpIHtcbiAgICAvLyBNYWNpbnRvc2gsIFJvbWFuLCBFbmdsaXNoXG4gICAgdmFyIHN0cmluZ0J5dGVzID0gZW5jb2RlLlNUUklORyhzKTtcbiAgICB0LnJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZCgxLCAwLCAwLCByZWNvcmRJRCwgc3RyaW5nQnl0ZXMubGVuZ3RoLCBvZmZzZXQpKTtcbiAgICB0LnN0cmluZ3MucHVzaChzdHJpbmdCeXRlcyk7XG4gICAgb2Zmc2V0ICs9IHN0cmluZ0J5dGVzLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBhZGRXaW5kb3dzTmFtZVJlY29yZCh0LCByZWNvcmRJRCwgcywgb2Zmc2V0KSB7XG4gICAgLy8gV2luZG93cywgVW5pY29kZSBCTVAgKFVDUy0yKSwgVVMgRW5nbGlzaFxuICAgIHZhciB1dGYxNkJ5dGVzID0gZW5jb2RlLlVURjE2KHMpO1xuICAgIHQucmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKDMsIDEsIDB4MDQwOSwgcmVjb3JkSUQsIHV0ZjE2Qnl0ZXMubGVuZ3RoLCBvZmZzZXQpKTtcbiAgICB0LnN0cmluZ3MucHVzaCh1dGYxNkJ5dGVzKTtcbiAgICBvZmZzZXQgKz0gdXRmMTZCeXRlcy5sZW5ndGg7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVUYWJsZShvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ25hbWUnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nT2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIHQucmVjb3JkcyA9IFtdO1xuICAgIHQuc3RyaW5ncyA9IFtdO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBpO1xuICAgIHZhciBzO1xuICAgIC8vIEFkZCBNYWNpbnRvc2ggcmVjb3JkcyBmaXJzdFxuICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lVGFibGVOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcyA9IG9wdGlvbnNbbmFtZVRhYmxlTmFtZXNbaV1dO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYWRkTWFjaW50b3NoTmFtZVJlY29yZCh0LCBpLCBzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZW4gYWRkIFdpbmRvd3MgcmVjb3Jkc1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lVGFibGVOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcyA9IG9wdGlvbnNbbmFtZVRhYmxlTmFtZXNbaV1dO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYWRkV2luZG93c05hbWVSZWNvcmQodCwgaSwgcywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHQuY291bnQgPSB0LnJlY29yZHMubGVuZ3RoO1xuICAgIHQuc3RyaW5nT2Zmc2V0ID0gNiArIHQuY291bnQgKiAxMjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdC5yZWNvcmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZWNvcmRfJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0LnJlY29yZHNbaV19KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdC5zdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHQuc3RyaW5nc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VOYW1lVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTmFtZVRhYmxlO1xuIiwiLy8gVGhlIGBPUy8yYCB0YWJsZSBjb250YWlucyBtZXRyaWNzIHJlcXVpcmVkIGluIE9wZW5UeXBlIGZvbnRzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9vczIuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbnZhciB1bmljb2RlUmFuZ2VzID0gW1xuICAgIHtiZWdpbjogMHgwMDAwLCBlbmQ6IDB4MDA3Rn0sIC8vIEJhc2ljIExhdGluXG4gICAge2JlZ2luOiAweDAwODAsIGVuZDogMHgwMEZGfSwgLy8gTGF0aW4tMSBTdXBwbGVtZW50XG4gICAge2JlZ2luOiAweDAxMDAsIGVuZDogMHgwMTdGfSwgLy8gTGF0aW4gRXh0ZW5kZWQtQVxuICAgIHtiZWdpbjogMHgwMTgwLCBlbmQ6IDB4MDI0Rn0sIC8vIExhdGluIEV4dGVuZGVkLUJcbiAgICB7YmVnaW46IDB4MDI1MCwgZW5kOiAweDAyQUZ9LCAvLyBJUEEgRXh0ZW5zaW9uc1xuICAgIHtiZWdpbjogMHgwMkIwLCBlbmQ6IDB4MDJGRn0sIC8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVyc1xuICAgIHtiZWdpbjogMHgwMzAwLCBlbmQ6IDB4MDM2Rn0sIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrc1xuICAgIHtiZWdpbjogMHgwMzcwLCBlbmQ6IDB4MDNGRn0sIC8vIEdyZWVrIGFuZCBDb3B0aWNcbiAgICB7YmVnaW46IDB4MkM4MCwgZW5kOiAweDJDRkZ9LCAvLyBDb3B0aWNcbiAgICB7YmVnaW46IDB4MDQwMCwgZW5kOiAweDA0RkZ9LCAvLyBDeXJpbGxpY1xuICAgIHtiZWdpbjogMHgwNTMwLCBlbmQ6IDB4MDU4Rn0sIC8vIEFybWVuaWFuXG4gICAge2JlZ2luOiAweDA1OTAsIGVuZDogMHgwNUZGfSwgLy8gSGVicmV3XG4gICAge2JlZ2luOiAweEE1MDAsIGVuZDogMHhBNjNGfSwgLy8gVmFpXG4gICAge2JlZ2luOiAweDA2MDAsIGVuZDogMHgwNkZGfSwgLy8gQXJhYmljXG4gICAge2JlZ2luOiAweDA3QzAsIGVuZDogMHgwN0ZGfSwgLy8gTktvXG4gICAge2JlZ2luOiAweDA5MDAsIGVuZDogMHgwOTdGfSwgLy8gRGV2YW5hZ2FyaVxuICAgIHtiZWdpbjogMHgwOTgwLCBlbmQ6IDB4MDlGRn0sIC8vIEJlbmdhbGlcbiAgICB7YmVnaW46IDB4MEEwMCwgZW5kOiAweDBBN0Z9LCAvLyBHdXJtdWtoaVxuICAgIHtiZWdpbjogMHgwQTgwLCBlbmQ6IDB4MEFGRn0sIC8vIEd1amFyYXRpXG4gICAge2JlZ2luOiAweDBCMDAsIGVuZDogMHgwQjdGfSwgLy8gT3JpeWFcbiAgICB7YmVnaW46IDB4MEI4MCwgZW5kOiAweDBCRkZ9LCAvLyBUYW1pbFxuICAgIHtiZWdpbjogMHgwQzAwLCBlbmQ6IDB4MEM3Rn0sIC8vIFRlbHVndVxuICAgIHtiZWdpbjogMHgwQzgwLCBlbmQ6IDB4MENGRn0sIC8vIEthbm5hZGFcbiAgICB7YmVnaW46IDB4MEQwMCwgZW5kOiAweDBEN0Z9LCAvLyBNYWxheWFsYW1cbiAgICB7YmVnaW46IDB4MEUwMCwgZW5kOiAweDBFN0Z9LCAvLyBUaGFpXG4gICAge2JlZ2luOiAweDBFODAsIGVuZDogMHgwRUZGfSwgLy8gTGFvXG4gICAge2JlZ2luOiAweDEwQTAsIGVuZDogMHgxMEZGfSwgLy8gR2VvcmdpYW5cbiAgICB7YmVnaW46IDB4MUIwMCwgZW5kOiAweDFCN0Z9LCAvLyBCYWxpbmVzZVxuICAgIHtiZWdpbjogMHgxMTAwLCBlbmQ6IDB4MTFGRn0sIC8vIEhhbmd1bCBKYW1vXG4gICAge2JlZ2luOiAweDFFMDAsIGVuZDogMHgxRUZGfSwgLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbFxuICAgIHtiZWdpbjogMHgxRjAwLCBlbmQ6IDB4MUZGRn0sIC8vIEdyZWVrIEV4dGVuZGVkXG4gICAge2JlZ2luOiAweDIwMDAsIGVuZDogMHgyMDZGfSwgLy8gR2VuZXJhbCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgyMDcwLCBlbmQ6IDB4MjA5Rn0sIC8vIFN1cGVyc2NyaXB0cyBBbmQgU3Vic2NyaXB0c1xuICAgIHtiZWdpbjogMHgyMEEwLCBlbmQ6IDB4MjBDRn0sIC8vIEN1cnJlbmN5IFN5bWJvbFxuICAgIHtiZWdpbjogMHgyMEQwLCBlbmQ6IDB4MjBGRn0sIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBGb3IgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyMTAwLCBlbmQ6IDB4MjE0Rn0sIC8vIExldHRlcmxpa2UgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyMTUwLCBlbmQ6IDB4MjE4Rn0sIC8vIE51bWJlciBGb3Jtc1xuICAgIHtiZWdpbjogMHgyMTkwLCBlbmQ6IDB4MjFGRn0sIC8vIEFycm93c1xuICAgIHtiZWdpbjogMHgyMjAwLCBlbmQ6IDB4MjJGRn0sIC8vIE1hdGhlbWF0aWNhbCBPcGVyYXRvcnNcbiAgICB7YmVnaW46IDB4MjMwMCwgZW5kOiAweDIzRkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFRlY2huaWNhbFxuICAgIHtiZWdpbjogMHgyNDAwLCBlbmQ6IDB4MjQzRn0sIC8vIENvbnRyb2wgUGljdHVyZXNcbiAgICB7YmVnaW46IDB4MjQ0MCwgZW5kOiAweDI0NUZ9LCAvLyBPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblxuICAgIHtiZWdpbjogMHgyNDYwLCBlbmQ6IDB4MjRGRn0sIC8vIEVuY2xvc2VkIEFscGhhbnVtZXJpY3NcbiAgICB7YmVnaW46IDB4MjUwMCwgZW5kOiAweDI1N0Z9LCAvLyBCb3ggRHJhd2luZ1xuICAgIHtiZWdpbjogMHgyNTgwLCBlbmQ6IDB4MjU5Rn0sIC8vIEJsb2NrIEVsZW1lbnRzXG4gICAge2JlZ2luOiAweDI1QTAsIGVuZDogMHgyNUZGfSwgLy8gR2VvbWV0cmljIFNoYXBlc1xuICAgIHtiZWdpbjogMHgyNjAwLCBlbmQ6IDB4MjZGRn0sIC8vIE1pc2NlbGxhbmVvdXMgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgyNzAwLCBlbmQ6IDB4MjdCRn0sIC8vIERpbmdiYXRzXG4gICAge2JlZ2luOiAweDMwMDAsIGVuZDogMHgzMDNGfSwgLy8gQ0pLIFN5bWJvbHMgQW5kIFB1bmN0dWF0aW9uXG4gICAge2JlZ2luOiAweDMwNDAsIGVuZDogMHgzMDlGfSwgLy8gSGlyYWdhbmFcbiAgICB7YmVnaW46IDB4MzBBMCwgZW5kOiAweDMwRkZ9LCAvLyBLYXRha2FuYVxuICAgIHtiZWdpbjogMHgzMTAwLCBlbmQ6IDB4MzEyRn0sIC8vIEJvcG9tb2ZvXG4gICAge2JlZ2luOiAweDMxMzAsIGVuZDogMHgzMThGfSwgLy8gSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xuICAgIHtiZWdpbjogMHhBODQwLCBlbmQ6IDB4QTg3Rn0sIC8vIFBoYWdzLXBhXG4gICAge2JlZ2luOiAweDMyMDAsIGVuZDogMHgzMkZGfSwgLy8gRW5jbG9zZWQgQ0pLIExldHRlcnMgQW5kIE1vbnRoc1xuICAgIHtiZWdpbjogMHgzMzAwLCBlbmQ6IDB4MzNGRn0sIC8vIENKSyBDb21wYXRpYmlsaXR5XG4gICAge2JlZ2luOiAweEFDMDAsIGVuZDogMHhEN0FGfSwgLy8gSGFuZ3VsIFN5bGxhYmxlc1xuICAgIHtiZWdpbjogMHhEODAwLCBlbmQ6IDB4REZGRn0sIC8vIE5vbi1QbGFuZSAwICpcbiAgICB7YmVnaW46IDB4MTA5MDAsIGVuZDogMHgxMDkxRn0sIC8vIFBob2VuaWNpYVxuICAgIHtiZWdpbjogMHg0RTAwLCBlbmQ6IDB4OUZGRn0sIC8vIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcbiAgICB7YmVnaW46IDB4RTAwMCwgZW5kOiAweEY4RkZ9LCAvLyBQcml2YXRlIFVzZSBBcmVhIChwbGFuZSAwKVxuICAgIHtiZWdpbjogMHgzMUMwLCBlbmQ6IDB4MzFFRn0sIC8vIENKSyBTdHJva2VzXG4gICAge2JlZ2luOiAweEZCMDAsIGVuZDogMHhGQjRGfSwgLy8gQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcbiAgICB7YmVnaW46IDB4RkI1MCwgZW5kOiAweEZERkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcbiAgICB7YmVnaW46IDB4RkUyMCwgZW5kOiAweEZFMkZ9LCAvLyBDb21iaW5pbmcgSGFsZiBNYXJrc1xuICAgIHtiZWdpbjogMHhGRTEwLCBlbmQ6IDB4RkUxRn0sIC8vIFZlcnRpY2FsIEZvcm1zXG4gICAge2JlZ2luOiAweEZFNTAsIGVuZDogMHhGRTZGfSwgLy8gU21hbGwgRm9ybSBWYXJpYW50c1xuICAgIHtiZWdpbjogMHhGRTcwLCBlbmQ6IDB4RkVGRn0sIC8vIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlxuICAgIHtiZWdpbjogMHhGRjAwLCBlbmQ6IDB4RkZFRn0sIC8vIEhhbGZ3aWR0aCBBbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAge2JlZ2luOiAweEZGRjAsIGVuZDogMHhGRkZGfSwgLy8gU3BlY2lhbHNcbiAgICB7YmVnaW46IDB4MEYwMCwgZW5kOiAweDBGRkZ9LCAvLyBUaWJldGFuXG4gICAge2JlZ2luOiAweDA3MDAsIGVuZDogMHgwNzRGfSwgLy8gU3lyaWFjXG4gICAge2JlZ2luOiAweDA3ODAsIGVuZDogMHgwN0JGfSwgLy8gVGhhYW5hXG4gICAge2JlZ2luOiAweDBEODAsIGVuZDogMHgwREZGfSwgLy8gU2luaGFsYVxuICAgIHtiZWdpbjogMHgxMDAwLCBlbmQ6IDB4MTA5Rn0sIC8vIE15YW5tYXJcbiAgICB7YmVnaW46IDB4MTIwMCwgZW5kOiAweDEzN0Z9LCAvLyBFdGhpb3BpY1xuICAgIHtiZWdpbjogMHgxM0EwLCBlbmQ6IDB4MTNGRn0sIC8vIENoZXJva2VlXG4gICAge2JlZ2luOiAweDE0MDAsIGVuZDogMHgxNjdGfSwgLy8gVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljc1xuICAgIHtiZWdpbjogMHgxNjgwLCBlbmQ6IDB4MTY5Rn0sIC8vIE9naGFtXG4gICAge2JlZ2luOiAweDE2QTAsIGVuZDogMHgxNkZGfSwgLy8gUnVuaWNcbiAgICB7YmVnaW46IDB4MTc4MCwgZW5kOiAweDE3RkZ9LCAvLyBLaG1lclxuICAgIHtiZWdpbjogMHgxODAwLCBlbmQ6IDB4MThBRn0sIC8vIE1vbmdvbGlhblxuICAgIHtiZWdpbjogMHgyODAwLCBlbmQ6IDB4MjhGRn0sIC8vIEJyYWlsbGUgUGF0dGVybnNcbiAgICB7YmVnaW46IDB4QTAwMCwgZW5kOiAweEE0OEZ9LCAvLyBZaSBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4MTcwMCwgZW5kOiAweDE3MUZ9LCAvLyBUYWdhbG9nXG4gICAge2JlZ2luOiAweDEwMzAwLCBlbmQ6IDB4MTAzMkZ9LCAvLyBPbGQgSXRhbGljXG4gICAge2JlZ2luOiAweDEwMzMwLCBlbmQ6IDB4MTAzNEZ9LCAvLyBHb3RoaWNcbiAgICB7YmVnaW46IDB4MTA0MDAsIGVuZDogMHgxMDQ0Rn0sIC8vIERlc2VyZXRcbiAgICB7YmVnaW46IDB4MUQwMDAsIGVuZDogMHgxRDBGRn0sIC8vIEJ5emFudGluZSBNdXNpY2FsIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MUQ0MDAsIGVuZDogMHgxRDdGRn0sIC8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9sc1xuICAgIHtiZWdpbjogMHhGRjAwMCwgZW5kOiAweEZGRkZEfSwgLy8gUHJpdmF0ZSBVc2UgKHBsYW5lIDE1KVxuICAgIHtiZWdpbjogMHhGRTAwLCBlbmQ6IDB4RkUwRn0sIC8vIFZhcmlhdGlvbiBTZWxlY3RvcnNcbiAgICB7YmVnaW46IDB4RTAwMDAsIGVuZDogMHhFMDA3Rn0sIC8vIFRhZ3NcbiAgICB7YmVnaW46IDB4MTkwMCwgZW5kOiAweDE5NEZ9LCAvLyBMaW1idVxuICAgIHtiZWdpbjogMHgxOTUwLCBlbmQ6IDB4MTk3Rn0sIC8vIFRhaSBMZVxuICAgIHtiZWdpbjogMHgxOTgwLCBlbmQ6IDB4MTlERn0sIC8vIE5ldyBUYWkgTHVlXG4gICAge2JlZ2luOiAweDFBMDAsIGVuZDogMHgxQTFGfSwgLy8gQnVnaW5lc2VcbiAgICB7YmVnaW46IDB4MkMwMCwgZW5kOiAweDJDNUZ9LCAvLyBHbGFnb2xpdGljXG4gICAge2JlZ2luOiAweDJEMzAsIGVuZDogMHgyRDdGfSwgLy8gVGlmaW5hZ2hcbiAgICB7YmVnaW46IDB4NERDMCwgZW5kOiAweDRERkZ9LCAvLyBZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1xuICAgIHtiZWdpbjogMHhBODAwLCBlbmQ6IDB4QTgyRn0sIC8vIFN5bG90aSBOYWdyaVxuICAgIHtiZWdpbjogMHgxMDAwMCwgZW5kOiAweDEwMDdGfSwgLy8gTGluZWFyIEIgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwMTQwLCBlbmQ6IDB4MTAxOEZ9LCAvLyBBbmNpZW50IEdyZWVrIE51bWJlcnNcbiAgICB7YmVnaW46IDB4MTAzODAsIGVuZDogMHgxMDM5Rn0sIC8vIFVnYXJpdGljXG4gICAge2JlZ2luOiAweDEwM0EwLCBlbmQ6IDB4MTAzREZ9LCAvLyBPbGQgUGVyc2lhblxuICAgIHtiZWdpbjogMHgxMDQ1MCwgZW5kOiAweDEwNDdGfSwgLy8gU2hhdmlhblxuICAgIHtiZWdpbjogMHgxMDQ4MCwgZW5kOiAweDEwNEFGfSwgLy8gT3NtYW55YVxuICAgIHtiZWdpbjogMHgxMDgwMCwgZW5kOiAweDEwODNGfSwgLy8gQ3lwcmlvdCBTeWxsYWJhcnlcbiAgICB7YmVnaW46IDB4MTBBMDAsIGVuZDogMHgxMEE1Rn0sIC8vIEtoYXJvc2h0aGlcbiAgICB7YmVnaW46IDB4MUQzMDAsIGVuZDogMHgxRDM1Rn0sIC8vIFRhaSBYdWFuIEppbmcgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgxMjAwMCwgZW5kOiAweDEyM0ZGfSwgLy8gQ3VuZWlmb3JtXG4gICAge2JlZ2luOiAweDFEMzYwLCBlbmQ6IDB4MUQzN0Z9LCAvLyBDb3VudGluZyBSb2QgTnVtZXJhbHNcbiAgICB7YmVnaW46IDB4MUI4MCwgZW5kOiAweDFCQkZ9LCAvLyBTdW5kYW5lc2VcbiAgICB7YmVnaW46IDB4MUMwMCwgZW5kOiAweDFDNEZ9LCAvLyBMZXBjaGFcbiAgICB7YmVnaW46IDB4MUM1MCwgZW5kOiAweDFDN0Z9LCAvLyBPbCBDaGlraVxuICAgIHtiZWdpbjogMHhBODgwLCBlbmQ6IDB4QThERn0sIC8vIFNhdXJhc2h0cmFcbiAgICB7YmVnaW46IDB4QTkwMCwgZW5kOiAweEE5MkZ9LCAvLyBLYXlhaCBMaVxuICAgIHtiZWdpbjogMHhBOTMwLCBlbmQ6IDB4QTk1Rn0sIC8vIFJlamFuZ1xuICAgIHtiZWdpbjogMHhBQTAwLCBlbmQ6IDB4QUE1Rn0sIC8vIENoYW1cbiAgICB7YmVnaW46IDB4MTAxOTAsIGVuZDogMHgxMDFDRn0sIC8vIEFuY2llbnQgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgxMDFEMCwgZW5kOiAweDEwMUZGfSwgLy8gUGhhaXN0b3MgRGlzY1xuICAgIHtiZWdpbjogMHgxMDJBMCwgZW5kOiAweDEwMkRGfSwgLy8gQ2FyaWFuXG4gICAge2JlZ2luOiAweDFGMDMwLCBlbmQ6IDB4MUYwOUZ9ICAvLyBEb21pbm8gVGlsZXNcbl07XG5cbmZ1bmN0aW9uIGdldFVuaWNvZGVSYW5nZSh1bmljb2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmljb2RlUmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHVuaWNvZGVSYW5nZXNbaV07XG4gICAgICAgIGlmICh1bmljb2RlID49IHJhbmdlLmJlZ2luICYmIHVuaWNvZGUgPCByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG5cbiAgICBvczIudWxVbmljb2RlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTMgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2U0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLmFjaFZlbmRJRCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSk7XG4gICAgb3MyLmZzU2VsZWN0aW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0ZpcnN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c0xhc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnNUeXBvQXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9EZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc1R5cG9MaW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2luQXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpbkRlc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDEpIHtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICB9XG5cbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMikge1xuICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzRGVmYXVsdENoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3MyO1xufVxuXG5mdW5jdGlvbiBtYWtlT1MyVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcbiAgICAgICAge25hbWU6ICd4QXZnQ2hhcldpZHRoJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZnNUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjUwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WVNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjk5fSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxNDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WVNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjk5fSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDc5fSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0U2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA0OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFBvc2l0aW9uJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDI1OH0sXG4gICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JGYW1pbHlUeXBlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlByb3BvcnRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkFybVN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JYSGVpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcbiAgICAgICAge25hbWU6ICdmc1NlbGVjdGlvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0FzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkFzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0RlZmF1bHRDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnVuaWNvZGVSYW5nZXMgPSB1bmljb2RlUmFuZ2VzO1xuZXhwb3J0cy5nZXRVbmljb2RlUmFuZ2UgPSBnZXRVbmljb2RlUmFuZ2U7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VPUzJUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VPUzJUYWJsZTtcbiIsIi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCcuLi9lbmNvZGluZycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGk7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgICAgcG9zdC5uYW1lcyA9IGVuY29kaW5nLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zdC5uYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA+PSBlbmNvZGluZy5zdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDIuNTpcbiAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc3Qub2Zmc2V0W2ldID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdDtcbn1cblxuZnVuY3Rpb24gbWFrZVBvc3RUYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdwb3N0JywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAzMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGUxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGUxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9XG4gICAgXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZVBvc3RUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VQb3N0VGFibGU7XG4iLCIvLyBUaGUgYHNmbnRgIHdyYXBwZXIgcHJvdmlkZXMgb3JnYW5pemF0aW9uIGZvciB0aGUgdGFibGVzIGluIHRoZSBmb250LlxuLy8gSXQgaXMgdGhlIHRvcC1sZXZlbCBkYXRhIHN0cnVjdHVyZSBpbiBhIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL290ZmYuaHRtXG4vLyBSZWNvbW1lbmRhdGlvbnMgZm9yIGNyZWF0aW5nIE9wZW5UeXBlIEZvbnRzOlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjMTQwL3JlY29tLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG52YXIgY21hcCA9IHJlcXVpcmUoJy4vY21hcCcpO1xudmFyIGNmZiA9IHJlcXVpcmUoJy4vY2ZmJyk7XG52YXIgaGVhZCA9IHJlcXVpcmUoJy4vaGVhZCcpO1xudmFyIGhoZWEgPSByZXF1aXJlKCcuL2hoZWEnKTtcbnZhciBobXR4ID0gcmVxdWlyZSgnLi9obXR4Jyk7XG52YXIgbWF4cCA9IHJlcXVpcmUoJy4vbWF4cCcpO1xudmFyIF9uYW1lID0gcmVxdWlyZSgnLi9uYW1lJyk7XG52YXIgb3MyID0gcmVxdWlyZSgnLi9vczInKTtcbnZhciBwb3N0ID0gcmVxdWlyZSgnLi9wb3N0Jyk7XG5cbmZ1bmN0aW9uIGxvZzIodikge1xuICAgIHJldHVybiBNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDIpIHwgMDtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKSB7XG4gICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuXG4gICAgc3VtICU9IE1hdGgucG93KDIsIDMyKTtcbiAgICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBtYWtlVGFibGVSZWNvcmQodGFnLCBjaGVja1N1bSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdUYWJsZSBSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAndGFnJywgdHlwZTogJ1RBRycsIHZhbHVlOiB0YWcgIT09IHVuZGVmaW5lZCA/IHRhZyA6ICcnfSxcbiAgICAgICAge25hbWU6ICdjaGVja1N1bScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjaGVja1N1bSAhPT0gdW5kZWZpbmVkID8gY2hlY2tTdW0gOiAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogb2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvZmZzZXQgOiAwfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbGVuZ3RoICE9PSB1bmRlZmluZWQgPyBsZW5ndGggOiAwfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlU2ZudFRhYmxlKHRhYmxlcykge1xuICAgIHZhciBzZm50ID0gbmV3IHRhYmxlLlRhYmxlKCdzZm50JywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVEFHJywgdmFsdWU6ICdPVFRPJ30sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFibGVzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcbiAgICBzZm50LnRhYmxlcyA9IHRhYmxlcztcbiAgICBzZm50Lm51bVRhYmxlcyA9IHRhYmxlcy5sZW5ndGg7XG4gICAgdmFyIGhpZ2hlc3RQb3dlck9mMiA9IE1hdGgucG93KDIsIGxvZzIoc2ZudC5udW1UYWJsZXMpKTtcbiAgICBzZm50LnNlYXJjaFJhbmdlID0gMTYgKiBoaWdoZXN0UG93ZXJPZjI7XG4gICAgc2ZudC5lbnRyeVNlbGVjdG9yID0gbG9nMihoaWdoZXN0UG93ZXJPZjIpO1xuICAgIHNmbnQucmFuZ2VTaGlmdCA9IHNmbnQubnVtVGFibGVzICogMTYgLSBzZm50LnNlYXJjaFJhbmdlO1xuXG4gICAgdmFyIHJlY29yZEZpZWxkcyA9IFtdO1xuICAgIHZhciB0YWJsZUZpZWxkcyA9IFtdO1xuXG4gICAgdmFyIG9mZnNldCA9IHNmbnQuc2l6ZU9mKCkgKyAobWFrZVRhYmxlUmVjb3JkKCkuc2l6ZU9mKCkgKiBzZm50Lm51bVRhYmxlcyk7XG4gICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0ID0gdGFibGVzW2ldO1xuICAgICAgICBjaGVjay5hcmd1bWVudCh0LnRhYmxlTmFtZS5sZW5ndGggPT09IDQsICdUYWJsZSBuYW1lJyArIHQudGFibGVOYW1lICsgJyBpcyBpbnZhbGlkLicpO1xuICAgICAgICB2YXIgdGFibGVMZW5ndGggPSB0LnNpemVPZigpO1xuICAgICAgICB2YXIgdGFibGVSZWNvcmQgPSBtYWtlVGFibGVSZWNvcmQodC50YWJsZU5hbWUsIGNvbXB1dGVDaGVja1N1bSh0LmVuY29kZSgpKSwgb2Zmc2V0LCB0YWJsZUxlbmd0aCk7XG4gICAgICAgIHJlY29yZEZpZWxkcy5wdXNoKHtuYW1lOiB0YWJsZVJlY29yZC50YWcgKyAnIFRhYmxlIFJlY29yZCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0YWJsZVJlY29yZH0pO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiB0LnRhYmxlTmFtZSArICcgdGFibGUnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdH0pO1xuICAgICAgICBvZmZzZXQgKz0gdGFibGVMZW5ndGg7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KCFpc05hTihvZmZzZXQpLCAnU29tZXRoaW5nIHdlbnQgd3JvbmcgY2FsY3VsYXRpbmcgdGhlIG9mZnNldC4nKTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWJsZSByZWNvcmRzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIHJlY29yZEZpZWxkcy5zb3J0KGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICBpZiAocjEudmFsdWUudGFnID4gcjIudmFsdWUudGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQocmVjb3JkRmllbGRzKTtcbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdCh0YWJsZUZpZWxkcyk7XG4gICAgcmV0dXJuIHNmbnQ7XG59XG5cbi8vIEdldCB0aGUgbWV0cmljcyBmb3IgYSBjaGFyYWN0ZXIuIElmIHRoZSBzdHJpbmcgaGFzIG1vcmUgdGhhbiBvbmUgY2hhcmFjdGVyXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbWV0cmljcyBmb3IgdGhlIGZpcnN0IGF2YWlsYWJsZSBjaGFyYWN0ZXIuXG4vLyBZb3UgY2FuIHByb3ZpZGUgb3B0aW9uYWwgZmFsbGJhY2sgbWV0cmljcyBpZiBubyBjaGFyYWN0ZXJzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBtZXRyaWNzRm9yQ2hhcihmb250LCBjaGFycywgbm90Rm91bmRNZXRyaWNzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGZvbnQuY2hhclRvR2x5cGhJbmRleChjaGFyc1tpXSk7XG4gICAgICAgIGlmIChnbHlwaEluZGV4ID4gMCkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHNbZ2x5cGhJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGguZ2V0TWV0cmljcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuZnVuY3Rpb24gYXZlcmFnZSh2cykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3VtICs9IHZzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIGZpcnN0Q2hhckluZGV4ID0gbnVsbDtcbiAgICB2YXIgbGFzdENoYXJJbmRleCA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMSA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMiA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlMyA9IDA7XG4gICAgdmFyIHVsVW5pY29kZVJhbmdlNCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tpXTtcbiAgICAgICAgdmFyIHVuaWNvZGUgPSBnbHlwaC51bmljb2RlIHwgMDtcbiAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZmlyc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RDaGFySW5kZXggPCB1bmljb2RlKSB7XG4gICAgICAgICAgICBsYXN0Q2hhckluZGV4ID0gdW5pY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9zMi5nZXRVbmljb2RlUmFuZ2UodW5pY29kZSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDMyKSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTEgfD0gMSA8PCBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDY0KSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTIgfD0gMSA8PCBwb3NpdGlvbiAtIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgOTYpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMyB8PSAxIDw8IHBvc2l0aW9uIC0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCAxMjMpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlNCB8PSAxIDw8IHBvc2l0aW9uIC0gOTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaWNvZGUgcmFuZ2VzIGJpdHMgPiAxMjMgYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9uLWltcG9ydGFudCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoZ2x5cGgubmFtZSA9PT0gJy5ub3RkZWYnKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG1ldHJpY3MgPSBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHhNaW5zLnB1c2gobWV0cmljcy54TWluKTtcbiAgICAgICAgeU1pbnMucHVzaChtZXRyaWNzLnlNaW4pO1xuICAgICAgICB4TWF4cy5wdXNoKG1ldHJpY3MueE1heCk7XG4gICAgICAgIHlNYXhzLnB1c2gobWV0cmljcy55TWF4KTtcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nKTtcbiAgICAgICAgcmlnaHRTaWRlQmVhcmluZ3MucHVzaChtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcpO1xuICAgICAgICBhZHZhbmNlV2lkdGhzLnB1c2goZ2x5cGguYWR2YW5jZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGZvbnQuYXNjZW5kZXIgIT09IHVuZGVmaW5lZCA/IGZvbnQuYXNjZW5kZXIgOiBnbG9iYWxzLnlNYXg7XG4gICAgZ2xvYmFscy5kZXNjZW5kZXIgPSBmb250LmRlc2NlbmRlciAhPT0gdW5kZWZpbmVkID8gZm9udC5kZXNjZW5kZXIgOiBnbG9iYWxzLnlNaW47XG5cbiAgICB2YXIgaGVhZFRhYmxlID0gaGVhZC5tYWtlKHtcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICB4TWluOiBnbG9iYWxzLnhNaW4sXG4gICAgICAgIHlNaW46IGdsb2JhbHMueU1pbixcbiAgICAgICAgeE1heDogZ2xvYmFscy54TWF4LFxuICAgICAgICB5TWF4OiBnbG9iYWxzLnlNYXhcbiAgICB9KTtcblxuICAgIHZhciBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKHtcbiAgICAgICAgeEF2Z0NoYXJXaWR0aDogTWF0aC5yb3VuZChnbG9iYWxzLmFkdmFuY2VXaWR0aEF2ZyksXG4gICAgICAgIHVzV2VpZ2h0Q2xhc3M6IDUwMCwgLy8gTWVkaXVtIEZJWE1FIE1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAgICAgdXNXaWR0aENsYXNzOiA1LCAvLyBNZWRpdW0gKG5vcm1hbCkgRklYTUUgTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcbiAgICAgICAgdXNMYXN0Q2hhckluZGV4OiBsYXN0Q2hhckluZGV4LFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTE6IHVsVW5pY29kZVJhbmdlMSxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMzogdWxVbmljb2RlUmFuZ2UzLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTQ6IHVsVW5pY29kZVJhbmdlNCxcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgdXNXaW5EZXNjZW50OiAtZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiAwfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICB9KTtcblxuICAgIHZhciBobXR4VGFibGUgPSBobXR4Lm1ha2UoZm9udC5nbHlwaHMpO1xuICAgIHZhciBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG4gICAgdmFyIGZ1bGxOYW1lID0gZm9udC5mYW1pbHlOYW1lICsgJyAnICsgZm9udC5zdHlsZU5hbWU7XG4gICAgdmFyIHBvc3RTY3JpcHROYW1lID0gZm9udC5mYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBmb250LnN0eWxlTmFtZTtcbiAgICB2YXIgbmFtZVRhYmxlID0gX25hbWUubWFrZSh7XG4gICAgICAgIGNvcHlyaWdodDogZm9udC5jb3B5cmlnaHQsXG4gICAgICAgIGZvbnRGYW1pbHk6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgZm9udFN1YmZhbWlseTogZm9udC5zdHlsZU5hbWUsXG4gICAgICAgIHVuaXF1ZUlEOiBmb250Lm1hbnVmYWN0dXJlciArICc6JyArIGZ1bGxOYW1lLFxuICAgICAgICBmdWxsTmFtZTogZnVsbE5hbWUsXG4gICAgICAgIHZlcnNpb246IGZvbnQudmVyc2lvbixcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuICAgICAgICB0cmFkZW1hcms6IGZvbnQudHJhZGVtYXJrLFxuICAgICAgICBtYW51ZmFjdHVyZXI6IGZvbnQubWFudWZhY3R1cmVyLFxuICAgICAgICBkZXNpZ25lcjogZm9udC5kZXNpZ25lcixcbiAgICAgICAgZGVzY3JpcHRpb246IGZvbnQuZGVzY3JpcHRpb24sXG4gICAgICAgIG1hbnVmYWN0dXJlclVSTDogZm9udC5tYW51ZmFjdHVyZXJVUkwsXG4gICAgICAgIGRlc2lnbmVyVVJMOiBmb250LmRlc2lnbmVyVVJMLFxuICAgICAgICBsaWNlbnNlOiBmb250LmxpY2Vuc2UsXG4gICAgICAgIGxpY2Vuc2VVUkw6IGZvbnQubGljZW5zZVVSTCxcbiAgICAgICAgcHJlZmVycmVkRmFtaWx5OiBmb250LmZhbWlseU5hbWUsXG4gICAgICAgIHByZWZlcnJlZFN1YmZhbWlseTogZm9udC5zdHlsZU5hbWVcbiAgICB9KTtcbiAgICB2YXIgcG9zdFRhYmxlID0gcG9zdC5tYWtlKCk7XG4gICAgdmFyIGNmZlRhYmxlID0gY2ZmLm1ha2UoZm9udC5nbHlwaHMsIHtcbiAgICAgICAgdmVyc2lvbjogZm9udC52ZXJzaW9uLFxuICAgICAgICBmdWxsTmFtZTogZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0TmFtZTogZm9udC5zdHlsZU5hbWUsXG4gICAgICAgIHBvc3RTY3JpcHROYW1lOiBwb3N0U2NyaXB0TmFtZSxcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtXG4gICAgfSk7XG4gICAgLy8gT3JkZXIgdGhlIHRhYmxlcyBhY2NvcmRpbmcgdG8gdGhlIHRoZSBPcGVuVHlwZSBzcGVjaWZpY2F0aW9uIDEuNC5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBmb250J3MgY2hlY2tTdW0gYW5kIHN0b3JlIGl0IGluIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50LlxuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuICAgIHZhciB0YWJsZUZpZWxkcyA9IHNmbnRUYWJsZS5maWVsZHM7XG4gICAgdmFyIGNoZWNrU3VtQWRqdXN0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFibGVGaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRhYmxlRmllbGRzW2ldLm5hbWUgPT09ICdoZWFkIHRhYmxlJykge1xuICAgICAgICAgICAgdGFibGVGaWVsZHNbaV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuICAgICAgICAgICAgY2hlY2tTdW1BZGp1c3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hlY2tTdW1BZGp1c3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxuZXhwb3J0cy5jb21wdXRlQ2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW07XG5leHBvcnRzLm1ha2UgPSBtYWtlU2ZudFRhYmxlO1xuZXhwb3J0cy5mb250VG9UYWJsZSA9IGZvbnRUb1NmbnRUYWJsZTtcbiIsIi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG4vKiBnbG9iYWwgV2Vha01hcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbnZhciBkZWNvZGUgPSB7fTtcbnZhciBlbmNvZGUgPSB7fTtcbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG59XG5cbi8vIE9wZW5UeXBlIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIENvbnZlcnQgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuZW5jb2RlLkJZVEUgPSBmdW5jdGlvbih2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodiA+PSAwICYmIHYgPD0gMjU1LCAnQnl0ZSB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAyNTUuJyk7XG4gICAgcmV0dXJuIFt2XTtcbn07XG5cbnNpemVPZi5CWVRFID0gY29uc3RhbnQoMSk7XG5cbi8vIENvbnZlcnQgYSA4LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuZW5jb2RlLkNIQVIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiLnB1c2godi5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbnNpemVPZi5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVTSE9SVCA9IGNvbnN0YW50KDIpO1xuXG4vLyBDb252ZXJ0IGEgMTYtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlNIT1JUID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDE2KSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5TSE9SVCA9IGNvbnN0YW50KDIpO1xuXG4vLyBDb252ZXJ0IGEgMjQtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDMgYnl0ZXMuXG5lbmNvZGUuVUlOVDI0ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuVUlOVDI0ID0gY29uc3RhbnQoMyk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5VTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5MT05HID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDMyKSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5MT05HID0gY29uc3RhbnQoNCk7XG5cbmVuY29kZS5GSVhFRCA9IGVuY29kZS5VTE9ORztcbnNpemVPZi5GSVhFRCA9IHNpemVPZi5VTE9ORztcblxuZW5jb2RlLkZXT1JEID0gZW5jb2RlLlNIT1JUO1xuc2l6ZU9mLkZXT1JEID0gc2l6ZU9mLlNIT1JUO1xuXG5lbmNvZGUuVUZXT1JEID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5VRldPUkQgPSBzaXplT2YuVVNIT1JUO1xuXG4vLyBGSVhNRSBJbXBsZW1lbnQgTE9OR0RBVEVUSU1FXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbn07XG5cbnNpemVPZi5MT05HREFURVRJTUUgPSBjb25zdGFudCg4KTtcblxuLy8gQ29udmVydCBhIDQtY2hhciB0YWcgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG5lbmNvZGUuVEFHID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSA0LCAnVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy4nKTtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgzKV07XG59O1xuXG5zaXplT2YuVEFHID0gY29uc3RhbnQoNCk7XG5cbi8vIENGRiBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmVuY29kZS5DYXJkOCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLkNhcmQ4ID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5DYXJkMTYgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLkNhcmQxNiA9IHNpemVPZi5VU0hPUlQ7XG5cbmVuY29kZS5PZmZTaXplID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuT2ZmU2l6ZSA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuU0lEID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5TSUQgPSBzaXplT2YuVVNIT1JUO1xuXG4vLyBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEpIHtcbiAgICAgICAgdiA9IHYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNDcsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTExMzEgJiYgdiA8PSAtMTA4KSB7XG4gICAgICAgIHYgPSAtdiAtIDEwODtcbiAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI1MSwgdiAmIDB4RkZdO1xuICAgIH0gZWxzZSBpZiAodiA+PSAtMzI3NjggJiYgdiA8PSAzMjc2Nykge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjE2KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMzIodik7XG4gICAgfVxufTtcblxuc2l6ZU9mLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLk5VTUJFUih2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGEgc2lnbmVkIG51bWJlciBiZXR3ZWVuIC0zMjc2OCBhbmQgKzMyNzY3IHRvIGEgdGhyZWUtYnl0ZSB2YWx1ZS5cbi8vIFRoaXMgZW5zdXJlcyB3ZSBhbHdheXMgdXNlIHRocmVlIGJ5dGVzLCBidXQgaXMgbm90IHRoZSBtb3N0IGNvbXBhY3QgZm9ybWF0LlxuZW5jb2RlLk5VTUJFUjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMik7XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZm91ci1ieXRlIHZhbHVlLlxuLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuLy8gYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjksICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjMyID0gY29uc3RhbnQoNCk7XG5cbmVuY29kZS5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHZhciB2YWx1ZSA9IHYudG9TdHJpbmcoKTtcblxuICAgIC8vIFNvbWUgbnVtYmVycyB1c2UgYW4gZXBzaWxvbiB0byBlbmNvZGUgdGhlIHZhbHVlLiAoZS5nLiBKYXZhU2NyaXB0IHdpbGwgc3RvcmUgMC4wMDAwMDAxIGFzIDFlLTcpXG4gICAgLy8gVGhpcyBjb2RlIGNvbnZlcnRzIGl0IGJhY2sgdG8gYSBudW1iZXIgd2l0aG91dCB0aGUgZXBzaWxvbi5cbiAgICB2YXIgbSA9IC9cXC4oXFxkKj8pKD86OXs1LDIwfXwwezUsMjB9KVxcZHswLDJ9KD86ZSguKyl8JCkvLmV4ZWModmFsdWUpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gcGFyc2VGbG9hdCgnMWUnICsgKChtWzJdID8gK21bMl0gOiAwKSArIG1bMV0ubGVuZ3RoKSk7XG4gICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQodiAqIGVwc2lsb24pIC8gZXBzaWxvbikudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB2YXIgbmliYmxlcyA9ICcnO1xuICAgIHZhciBpO1xuICAgIHZhciBpaTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSB2YWx1ZVtpXTtcbiAgICAgICAgaWYgKGMgPT09ICdlJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSB2YWx1ZVsrK2ldID09PSAnLScgPyAnYycgOiAnYic7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9ICdhJztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2UnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmliYmxlcyArPSBjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmliYmxlcyArPSAobmliYmxlcy5sZW5ndGggJiAxKSA/ICdmJyA6ICdmZic7XG4gICAgdmFyIG91dCA9IFszMF07XG4gICAgZm9yIChpID0gMCwgaWkgPSBuaWJibGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgb3V0LnB1c2gocGFyc2VJbnQobmliYmxlcy5zdWJzdHIoaSwgMiksIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8vIENvbnZlcnQgYSBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIFVURjE2IGJ5dGVzLlxuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGIucHVzaCgwKTtcbiAgICAgICAgYi5wdXNoKHYuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG5zaXplT2YuVVRGMTYgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgaTtcbiAgICAvL3ZhciBvZmZzZXQsIG9mZnNldHMsIG9mZnNldEVuY29kZXIsIGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0LCBkYXRhLFxuICAgIC8vICAgIGRhdGFTaXplLCBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZmV0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIHZhciBvZmZzZXQgPSAxOyAvLyBGaXJzdCBvZmZzZXQgaXMgYWx3YXlzIDEuXG4gICAgdmFyIG9mZnNldHMgPSBbb2Zmc2V0XTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBkYXRhU2l6ZSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHYgPSBlbmNvZGUuT0JKRUNUKGxbaV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkYXRhLCB2KTtcbiAgICAgICAgZGF0YVNpemUgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSB2Lmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgdmFyIG9mZlNpemUgPSAoMSArIE1hdGguZmxvb3IoTWF0aC5sb2coZGF0YVNpemUpIC8gTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIHZhciBvZmZzZXRFbmNvZGVyID0gW3VuZGVmaW5lZCwgZW5jb2RlLkJZVEUsIGVuY29kZS5VU0hPUlQsIGVuY29kZS5VSU5UMjQsIGVuY29kZS5VTE9OR11bb2ZmU2l6ZV07XG4gICAgZm9yIChpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGVuY29kZWRPZmZzZXQgPSBvZmZzZXRFbmNvZGVyKG9mZnNldHNbaV0pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmNvZGVkT2Zmc2V0cywgZW5jb2RlZE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoZW5jb2RlLkNhcmQxNihsLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUuT2ZmU2l6ZShvZmZTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRPZmZzZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG59O1xuXG5zaXplT2YuSU5ERVggPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbi8vIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobSk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBPYmplY3Qua2V5cygpIHJldHVybiBzdHJpbmcga2V5cywgYnV0IG91ciBrZXlzIGFyZSBhbHdheXMgbnVtZXJpYy5cbiAgICAgICAgdmFyIGsgPSBwYXJzZUludChrZXlzW2ldLCAwKTtcbiAgICAgICAgdmFyIHYgPSBtW2tdO1xuICAgICAgICAvLyBWYWx1ZSBjb21lcyBiZWZvcmUgdGhlIGtleS5cbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHYudmFsdWUsIHYudHlwZSkpO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBVE9SKGspKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbnNpemVPZi5ESUNUID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBlbmNvZGUuRElDVChtKS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuT1BFUkFUT1IgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24odiwgdHlwZSkge1xuICAgIHZhciBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaGVjay5hcmd1bWVudCh2Lmxlbmd0aCA9PT0gdHlwZS5sZW5ndGgsICdOb3QgZW5vdWdoIGFyZ3VtZW50cyBnaXZlbiBmb3IgdHlwZScgKyB0eXBlKTtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2W2ldLCB0eXBlW2ldKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgLy8gV2UgbWFrZSBpdCBlYXN5IGZvciBvdXJzZWx2ZXMgYW5kIGFsd2F5cyBlbmNvZGUgb2Zmc2V0cyBhc1xuICAgICAgICAgICAgLy8gNCBieXRlcy4gVGhpcyBtYWtlcyBvZmZzZXQgY2FsY3VsYXRpb24gZm9yIHRoZSB0b3AgZGljdCBlYXNpZXIuXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUjMyKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZWFsJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5SRUFMKHYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvcGVyYW5kIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbmVuY29kZS5PUCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9QID0gc2l6ZU9mLkJZVEU7XG5cbi8vIG1lbW9pemUgY2hhcnN0cmluZyBlbmNvZGluZyB1c2luZyBXZWFrTWFwIGlmIGF2YWlsYWJsZVxudmFyIHdtbSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG4vLyBDb252ZXJ0IGEgbGlzdCBvZiBDaGFyU3RyaW5nIG9wZXJhdGlvbnMgdG8gYnl0ZXMuXG5lbmNvZGUuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuICAgIGlmICh3bW0gJiYgd21tLmhhcyhvcHMpKSB7XG4gICAgICAgIHJldHVybiB3bW0uZ2V0KG9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gb3BzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlW29wLnR5cGVdKG9wLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICB3bW0uc2V0KG9wcywgZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5zaXplT2YuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuICAgIHJldHVybiBlbmNvZGUuQ0hBUlNUUklORyhvcHMpLmxlbmd0aDtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIENvbnZlcnQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZSB0byBieXRlcy5cbmVuY29kZS5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8vIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4vLyBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuLy8gVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGluZ0Z1bmN0aW9uKHZhbHVlKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGJ5dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8vIE1lcmdlIGluIGEgbGlzdCBvZiBieXRlcy5cbmVuY29kZS5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuc2l6ZU9mID0gc2l6ZU9mO1xuIl19
